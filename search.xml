<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>深度工作：效率越高的人，越懂得这四种技巧</title>
    <url>/2019/05/26/%E6%B7%B1%E5%BA%A6%E5%B7%A5%E4%BD%9C%EF%BC%9A%E6%95%88%E7%8E%87%E8%B6%8A%E9%AB%98%E7%9A%84%E4%BA%BA%EF%BC%8C%E8%B6%8A%E6%87%82%E5%BE%97%E8%BF%99%E4%BA%94%E7%A7%8D%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p><img src="/images/%E6%B7%B1%E5%BA%A6%E5%B7%A5%E4%BD%9C%EF%BC%9A%E6%95%88%E7%8E%87%E8%B6%8A%E9%AB%98%E7%9A%84%E4%BA%BA%EF%BC%8C%E8%B6%8A%E6%87%82%E5%BE%97%E8%BF%99%E4%BA%94%E7%A7%8D%E6%8A%80%E5%B7%A7/%E6%B7%B1%E5%BA%A6%E5%B7%A5%E4%BD%9C.jpg" alt="深度工作"></p>
<a id="more"></a>

<h4 id="一、工作要深入：6个策略"><a href="#一、工作要深入：6个策略" class="headerlink" title="一、工作要深入：6个策略"></a>一、工作要深入：6个策略</h4><ul>
<li><p>选定适合你的深度哲学</p>
<ul>
<li><p>禁欲主义哲学，指摒弃或最小化浮浅职责，实现深度工作最大化。如计算机科学家唐纳德·克努特通过屏蔽个人邮箱，实现无人干扰的高度专注。</p>
</li>
<li><p>双峰哲学，指将时间分成两块，分别用于深度工作和其他事务。如卡尔·荣格隐居树林里的小石屋，将一部分时间用于不受干扰地写作；其它时间则用于在诊所看病、在大学讲课等。</p>
</li>
<li><p>节奏哲学，指将深度工作转化成常规习惯。例如链条法：每天坚持某个习惯，并且在每天完成后，在日历上划一个大大的红×，过几天就能连成一条链子。继续保持下去，这条链子会越来越长。</p>
</li>
<li><p>新闻记者哲学，指随时可插入深度工作。如记者沃尔特·艾萨克森因为工作的训练，让他养成了特别的工作习惯——只要有空闲时间，他就能立刻转入深度工作模式。</p>
</li>
</ul>
</li>
<li><p>习惯化</p>
<ul>
<li><p>通过养成严格内化的习惯，实现最大化的深度工作效果。如查尔斯·达尔文在雕琢《物种起源》期间，每天按照严格的时间，有条不紊地进行拆阅信件、思考、工作等</p>
</li>
<li><p>养成高效习惯应注意的普遍问题：</p>
<ul>
<li><p>第一，确定适合进行深度工作的场所，并设定工作时长。</p>
</li>
<li><p>第二，设置工作时的规则和程序，确保努力具有结构性。比如规定不能使用网络，或者设定每隔20分钟产出的文字数量。</p>
</li>
<li><p>第三，做些事支持自己的工作，确保大脑保持高深度水平。比如提供足够的食物，或通过散步等方式帮助大脑保持清醒。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>要有大手笔</p>
<ul>
<li><p>通过对周围惯常环境做出巨大的改变，辅以投入可观的精力或金钱，由此提升任务的外现重要性。这种重要性的提升，将降低大脑继续拖延的本能，让人更有激情和能量投入深度工作。</p>
<p><code>案 例：J.K.罗琳写作《死亡圣器》期间，入住爱丁堡中心的五星级酒店，由此完成了《哈利·波特》系列的最后一本书</code></p>
</li>
</ul>
</li>
<li><p>不要独自工作</p>
<ul>
<li><p>在恰当时机采用协作方式，可以推动深度工作取得更好的成果。但不能过分追求交流，以免破坏专注的状态。</p>
<p><code>案 例：贝尔实验室的开放空间将固态物理学家、量子论学家和世界一流的实验物理学者汇聚一堂。这样的协同交流成为发明晶体管的前提。</code></p>
</li>
</ul>
</li>
<li><p>像经商一样执行（4个原则）</p>
<ul>
<li><p>第一，明确最高目标。这样有助于集中精力达成目标。</p>
</li>
<li><p>第二，抓住引领性指标，即专注于在最高目标上投入的深度工作时间。</p>
</li>
<li><p>第三，准备醒目计分板。将深度工作时间记录在计分板上，一方面营造竞争氛围，驱使人专注，另一方面可以强化动机。</p>
</li>
<li><p>第四，定期问责。比如在每周工作回顾中，反省自己的表现以不断调整，并利用它制定下一周的工作计划。</p>
</li>
</ul>
</li>
<li><p>图安逸：定期放松大脑有助于深度工作</p>
<ul>
<li><p>定期放松大脑的三个原因：</p>
<ul>
<li><p>第一，安逸时光利于提升洞察力。给有意识的头脑休息的时间，可以激活无意识头脑，从而理清复杂的工作挑战。</p>
</li>
<li><p>第二，安逸时光利于补充深度工作能量。保持专注需要自主性注意力，但它是有限的，而无干扰的休息可让自主性注意力复原。</p>
</li>
<li><p>第三，晚间安逸时光中放下的工作一般没那么重要。如果日程安排合理，白天的工作时间就已经达到每日深度工作的极限了，那么在夜里就没有足够的精力做到深度工作。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="二、拥抱无聊，克服分心：4个策略"><a href="#二、拥抱无聊，克服分心：4个策略" class="headerlink" title="二、拥抱无聊，克服分心：4个策略"></a>二、拥抱无聊，克服分心：4个策略</h4><ul>
<li><p>忌不断分心，要不断专注</p>
<ul>
<li><p>预先计划好使用网络的时间，并严格执行，通过减少自己向分心屈服的次数，提升专注力。这一策略强调三个重点：</p>
<ul>
<li><p>一是即使工作需要大量使用网络和快速回复电子邮件，这个策略也适用。</p>
</li>
<li><p>二是不论怎么计划使用网络的时段，都必须保证在这些时段外彻底屏蔽网络。</p>
</li>
<li><p>三是在工作外也按计划使用网络，可以进一步提升专注训练的效果。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>像罗斯福一样工作</p>
<ul>
<li><p>西奥多·罗斯福就读哈佛期间，兴趣广泛，同时研究自然学，而且学习成绩也十分优秀，大一时就出版了第一本书，被称为“美国最博学的青年自然学者之一”。这些成果的取得，得益于他处理学业的独特方式：从上午8点半到下午4点半这段时间，他预留出时间背诵、上课、锻炼和吃午饭，余下的时间则全部用于专注其它学习。</p>
</li>
<li><p>这一策略启发我们：<strong>在日常工作中，要不时地像罗斯福一样发起冲锋，以高强度工作，高效利用时间，实现专注力的高度集中</strong>。</p>
</li>
</ul>
</li>
<li><p>有成果的冥想</p>
<ul>
<li><p>利用本可能被浪费的时间，如在走路、慢跑、开车时，将注意力集中在某个难题上，实现有成果的冥想。有效执行这一策略，有两个建议：</p>
</li>
<li><p>一是小心分心和原地打转。它们会阻碍冥想成果，所以必须警惕和提醒自己。</p>
</li>
<li><p>二是组织你的深度思考。深度思考需要一定的架构。作者建议首先仔细考察解决这个问题的相关变量。比如你在试图解决一个数学证明，它的相关变量可能是假设或前提。通过考虑相关变量，明确下一步问题，为自己的注意力指明方向。</p>
</li>
</ul>
</li>
<li><p>记住一副牌</p>
<ul>
<li><p>人的大脑不适合记忆抽象信息，而擅长记住场景。美国记忆力冠军罗恩·怀特的记牌窍门，就是基于这一见解而获得。这一窍门包括三个步骤：</p>
<ul>
<li><p>步骤一：穿行家里的5个房间，记住每个房间看到的10件物品，再加上院子里的2件，凑齐52个。</p>
</li>
<li><p>步骤二：将52张牌中的每一张与一个难忘的人或东西相对应。为方便起先，给每一张安排一个有逻辑联想的形象。</p>
</li>
<li><p>步骤三：在脑海中穿行每个房间，把遇到的每一件物品与难忘的人或东西，以及某张牌对应起来。连续多走几次，以便铭记脑中。</p>
</li>
<li><p>作者强调这一策略的关键是：<strong>只要你愿意付出努力，就可以提高专注力</strong>。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="三、-远离社交媒体，谨慎选择网络工具：3个策略"><a href="#三、-远离社交媒体，谨慎选择网络工具：3个策略" class="headerlink" title="三、 远离社交媒体，谨慎选择网络工具：3个策略"></a>三、 远离社交媒体，谨慎选择网络工具：3个策略</h4><ul>
<li><p>采用关键少数法则</p>
<ul>
<li><p>关键少数法则，是指在许多情境中，80%的已知效果源自20%的可能原因。这提醒我们最重要的20%的活动做出了大部分的贡献。也就是说，将时间花在高影响力的活动上，才能最大限度达成目标。这一策略包括两步：</p>
<ul>
<li><p>第一步：明确职业和私人生活中的高层次目标。</p>
</li>
<li><p>第二步：以高层次目标为准绳，思考当前使用的网络工具，评估它对达成该目标是积极影响、消极影响，还是无影响。</p>
</li>
<li><p>而决断标准是：<strong>只有你认为一种工具会带来积极影响，并且这些积极影响大于消积影响时，才继续使用这种工具</strong>。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>戒掉社交媒体</p>
<ul>
<li><p>尝试30天不使用社交媒体服务，不用主动告诉他人这个消息，也不用删除这些服务。经过30天的网络孤立，针对当前戒掉的每一个服务，问自己两个问题：第一，如果一直用这种服务，过去30天会过得更好吗？第二，人们是否关心我有没有在用这种服务？</p>
</li>
<li><p>如果这两个问题的答案是“否”，那么永久戒掉这项服务，如果答案是“是”，则重新启用。如果答案不肯定或模糊，则自行决定是否重新使用。</p>
</li>
<li><p>需要强调的是：<strong>多数人在社交媒体中刷存在感的做法，让他们草率地将时间和精力碎片化。社交媒体只是产品，它们可能会有趣，但对我们的人生目标无足轻重，而且它们是我们完成深度工作的巨大阻碍</strong>。</p>
</li>
</ul>
</li>
<li><p>不要用网络来消遣</p>
<ul>
<li><p>在生活中，如果我们把每个无聊的时刻（如排队5分钟，餐厅等朋友）都用来浏览智能手机，那么大脑可能已经被重新编排，这将导致我们不能胜任深度工作。</p>
</li>
<li><p>在空闲时，如果没有给自己安排特定的任务，网络是一种极具诱惑的选择。如果你想抵御诱惑，就得给大脑找些高质量的活动代替，如读书、运动、与益友面对面交流等等。这样能避免分心，保持专注的能力，也让我们活得更充实。</p>
</li>
</ul>
</li>
</ul>
<h4 id="四、砍掉浮浅工作：5个策略"><a href="#四、砍掉浮浅工作：5个策略" class="headerlink" title="四、砍掉浮浅工作：5个策略"></a>四、砍掉浮浅工作：5个策略</h4><ul>
<li><p>做好一天的计划</p>
<ul>
<li><p>这一策略重在使人们认识到，深度工作要求我们尊重自己的时间。作者建议：为本策略准备一本笔记本，提前规划好每个工作日的工作安排。但需要注意：允许日程中有突发改变，甚至可以主动寻求改变。</p>
</li>
<li><p>具有综合计划能力和愿意修改自己计划的人，相比没有任何规划的人，将享有更多的创造性洞见。</p>
</li>
</ul>
</li>
<li><p>定量分析每项活动的深度</p>
<ul>
<li><p>这一策略，要求我们明确每个工作任务的深浅度，以便将更多的精力倾注于深度工作。</p>
</li>
<li><p>评估工作深浅度时需要注意两点：一是，需要大量专业技能的工作，极有可能是深度工作。它既有更多的价值回报，又可以锻炼能力。二是，比如让大学生能够很快上手、不会提高专业技能的工作，大多是浮浅工作。</p>
</li>
</ul>
</li>
<li><p>向老板申请浮浅工作预算</p>
<ul>
<li><p>设置浮浅工作时间，并将它控制在这个预算范围内。对于大多数非入门级知识工作岗位，浮浅工作预算通常在工作时间的30%～50%之间。</p>
</li>
<li><p>如果自己是老板，应该问自己这个问题。因为你“繁忙”的日程中，只有少部分时间真正产出价值。</p>
</li>
<li><p>如果自己是员工，应该和老板谈论这个问题。这样做是为了，使你在特定情况下，能够更合理地拒绝某项任务或减少浮浅工作量。</p>
</li>
</ul>
</li>
<li><p>5点半之前结束工作</p>
<ul>
<li><p>除极个别例外，作者不在5点半后发电子邮件。一般来说，电子邮件和我们的工作紧密相连，也就是说作者不在5点半后工作。他把这种坚持叫做固定日程生产力，即确定一个工作目标，并设置工作时间上限，达到时间上限时则停止工作，而在工作时则专注于有生产效率的深度工作。固定日程生产力能获得成果的原因有两个：</p>
<ul>
<li><p>一是，采用固定日程生产力的方法，让人在做选择时有所侧重。这样能促使我们严格缩减浮浅工作，保持深度，在解放了时间的同时，保证创造的价值也不会减少。</p>
</li>
<li><p>二是，因为时间有限，才能更谨慎地思考个人的组织习惯。这使得我们产出的价值，高于花费长时间但日程安排混乱的人。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>变得不容易联系到</p>
<ul>
<li><p>掌握电子通讯中耗费的时间和精力的控制权，有三个技巧：</p>
<ul>
<li><p>第一，让发电子邮件的人做更多工作。如作者使用“发件人过滤器”的方法：如果有人要联系他，可以在网站上找到一个特殊情况专用电子邮件地址，同时会附带“不要对收到回复报太大期望”的信息。</p>
</li>
<li><p>第二，自己在收发电子邮件时做更多工作。如作者运用“流程导向”的方法，即梳理收到邮件的信息指向哪一个项目，成功完成项目接下来要做什么？<br>在回复邮件前，多花些时间理清当前处于哪个步骤，然后强调接下来的步骤。这样可以减少收到的邮件数量和漫无目的的思维混乱。</p>
</li>
<li><p>第三，不要回复。在你职业环境允许的情况下，这一技巧可参考以下三条规则，区分哪些信息不需要回复：</p>
<ul>
<li><p>其一，邮件内容含混或者存在其他问题，很难给一个合理的回复。</p>
</li>
<li><p>其二，你对这个问题或者提议不感兴趣。</p>
</li>
<li><p>其三，如果回复，不会有好结果；如果不回复，也不会有好结果。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="五、结语"><a href="#五、结语" class="headerlink" title="五、结语"></a>五、结语</h4><blockquote>
<p>作家威妮弗雷德·加拉格尔说：<br>我将活出专注的人生，因为这是最好的选择。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">深度的生活并非你必须要这么做，而是如果你想拥有更富效率和更有意义的人生，你就得跨过舒适区和恐惧，将自己的头脑发挥到极致。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>深度工作</tag>
      </tags>
  </entry>
  <entry>
    <title>动态调试的那些事儿</title>
    <url>/2019/04/11/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
    <content><![CDATA[<blockquote>
<p>对于苹果开发者而言，<code>LLDB</code> 是无人不知的调试工具，然而此知非彼知，相信有相当规模的开发者对 <code>LLDB</code> 的了解仍然停留于几个基础命令的使用，今天让我们来重新认识一下既熟悉又陌生的 <code>LLDB</code>，看看它那些你不曾用过的强大功能，以及如何提高我们的开发效率。</p>
</blockquote>
<a id="more"></a>

<h3 id="一、什么叫动态调试"><a href="#一、什么叫动态调试" class="headerlink" title="一、什么叫动态调试"></a>一、什么叫动态调试</h3><blockquote>
<p>将程序运行起来，通过下断点、打印等⽅方式，查看参数、返回值、函数调⽤用流程等</p>
</blockquote>
<h3 id="二、Xcode-的动态调试原理"><a href="#二、Xcode-的动态调试原理" class="headerlink" title="二、Xcode 的动态调试原理"></a>二、Xcode 的动态调试原理</h3><p><img src="/images/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86.png" alt="动态调试原理"></p>
<ul>
<li><p>关于 <strong>GCC、LLVM、GDB、LLDB</strong></p>
<ul>
<li>Xcode 的 <code>编译器</code> 发展历程：<a href="https://www.gnu.org/software/gcc/" target="_blank" rel="noopener">GCC</a> → <a href="https://llvm.org/" target="_blank" rel="noopener">LLVM</a></li>
<li>Xcode 的 <code>调试器</code> 发展历程：<a href="https://www.gnu.org/software/gdb/" target="_blank" rel="noopener">GDB</a> → <a href="https://lldb.llvm.org/" target="_blank" rel="noopener">LLDB</a> </li>
</ul>
</li>
<li><p>debugserver一开始存放在Mac的Xcode⾥面</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport/<span class="number">9.1</span>/DeveloperDiskImage.dmg/usr/bin/debugserver</span><br></pre></td></tr></table></figure>
</li>
<li><p>当Xcode识别到手机设备时，Xcode会自动将debugserver安装到iPhone上 </p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;Developer&#x2F;usr&#x2F;bin&#x2F;debugserver</span><br></pre></td></tr></table></figure>
</li>
<li><p>Xcode调试的局限性   </p>
<ul>
<li>一般情况下,只能调试通过 Xcode 安装的 App</li>
</ul>
</li>
</ul>
<h3 id="三、动态调试任意-App"><a href="#三、动态调试任意-App" class="headerlink" title="三、动态调试任意 App"></a>三、动态调试任意 App</h3><p><img src="/images/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E4%BB%BB%E6%84%8FApp.png" alt="动态调试任意App"></p>
<p><strong>1、debugserver 的权限问题</strong></p>
<ul>
<li>默认情况下，<code>/Developer/usr/bin/debugserver</code> 缺少一定的权限，只能调试通过 Xcode 安装的 APP，无法调试其他 App (⽐如来⾃自 App Store 的 App) </li>
<li>如果希望调试其他App，需要对 <code>debugserver</code> 重新签名，签上<strong>2</strong>个调试相关的权限<ul>
<li>get-task-allow</li>
<li>task_for_pid-allow</li>
</ul>
</li>
</ul>
<p><strong>2、如何给 debugserver 签上权限</strong></p>
<ul>
<li>iPhone上的 <code>/Developer</code> ⽬录是只读的，无法直接对 <code>/Developer/usr/bin/debugserver</code> ⽂件签名，需要先把 <code>debugserver</code> 复制到 Mac 上</li>
<li>通过 <code>ldid</code> 命令导出⽂件以前的签名权限<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ldid -e debugserver &gt; debugserver.entitlements</span><br></pre></td></tr></table></figure></li>
<li>给 <strong>debugserver.plist</strong> 文件加上 <code>get-task-allow</code> 和 <code>task_for_pid-allow</code> 权限<br><img src="/images/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/debugserver%E6%9D%83%E9%99%90.png" alt="debugserver权限"></li>
<li>通过<code>ldid</code>命令重新签名<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ldid -S debugserver.entitlements debugserver</span><br></pre></td></tr></table></figure></li>
<li>将已经签好权限的<code>debugserver</code>放到<code>/usr/bin</code>目录，便于找到<code>debugserver</code>指令 </li>
<li><code>debugserver</code>添加执行权限<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xhmod +x &#x2F;usr&#x2F;bin&#x2F;debugserver</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>3、让 debugserver 附加到某个 App 进程</strong></p>
<ul>
<li><p>执行下面的命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">debugserver *:端口号 -a 进程</span><br></pre></td></tr></table></figure>

<p>*:端口号：使用 iPhone 的某个端口启动 debugserver 服务(只要不是保留端⼝号就行)</p>
<p>-a 进程：输入 App 的进程信息(进程 ID 或者进程名称)</p>
</li>
</ul>
<p><strong>4、在 Mac 上启动 LLDB，远程连接 iPhone 上的 debugserver 服务</strong></p>
<ul>
<li><p>启动LLDB</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lldb</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>
</li>
<li><p>连接 debugserver 服务 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) process connect connect:&#x2F;&#x2F;手机IP地址:debugserver服务端⼝号</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 LLDB 的 <code>c</code> 命令让程序先继续运⾏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) c</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来就可以使⽤用 LLDB 命令调试App</p>
</li>
</ul>
<p><strong>5、通过debugserver启动App</strong></p>
<ul>
<li><p>执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">debugserver -x auto *:端⼝号 APP的可执⾏文件路径</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="四、常用LLDB指令"><a href="#四、常用LLDB指令" class="headerlink" title="四、常用LLDB指令"></a>四、常用LLDB指令</h3><ul>
<li><p>指令的格式是</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;command&gt; [&lt;subcommand&gt; [&lt;subcommand&gt;...]] &lt;action&gt; [-options [option-value]] [argument [argument...]]</span><br></pre></td></tr></table></figure>

<p>  <code>&lt;command&gt;</code>：命令</p>
<p>  <code>&lt;subcommand&gt;</code>：子命令</p>
<p>  <code>&lt;action&gt;</code>：命令操作，想在前面的命令序列的上下文中执行的一些操作</p>
<p>  <code>&lt;options&gt;</code>：命令选项，行为修改器(action modifiers)，通常带有一些值。</p>
<p>  <code>&lt;argument&gt;</code>：命令参数，据使用的命令的上下文来表示各种不同的东西</p>
<p>  <code>[]</code>：表示命令是可选的，可以有也可以没有。</p>
<p>  举个例子：给 <code>test</code> 函数设置断点</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">breakpoint set -n test</span><br></pre></td></tr></table></figure>

<p>  <strong>breakpoint</strong> 是 <code>&lt;command&gt;</code>,  <strong>set</strong> 是 <code>&lt;action&gt;</code>,  <strong>-n</strong> 是 <code>&lt;options&gt;</code> ，<strong>test</strong> 是  <code>&lt;argument&gt;</code></p>
</li>
<li><p>可以查看指令的用法：<code>help&lt;command&gt;</code>，比如</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">help breakpoint</span><br><span class="line">help breakpoint set</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行⼀个表达式：<code>expression&lt;cmd-options&gt; -- &lt;expr&gt;</code></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expression self.view.backgroundColor &#x3D; [UIColor redColor]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;cmd-options&gt;</code> : 命令选项</li>
<li><code>--</code> : 命令选项结束符，表示所有的命令选项已经设置完毕，如果没有命令选项，<code>--</code> 可以省略</li>
</ul>
</li>
<li><p><code>&lt;expr&gt;</code> : 需要执⾏的表达式</p>
<ul>
<li><code>expression</code>、<code>expression --</code> 和指令  <code>print</code>、 <code>p</code>、 <code>call</code>的效果一样 </li>
<li><code>expression -O --</code> 和指令 <code>po</code> 的效果⼀样</li>
</ul>
</li>
<li><p>打印线程的堆栈信息，和指令 <code>bt</code> 的效果一样</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread backtrace</span><br></pre></td></tr></table></figure>
</li>
<li><p>让函数直接返回某个值，不会执行断点后面的代码</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread return [&lt;expr&gt;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>打印当前栈帧的变量量</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frame variable [&lt;variable name&gt;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>程序继续运行</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread continue</span><br><span class="line">continue</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
</li>
<li><p>单步运⾏，把子函数当做整体一步执⾏</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread step-over</span><br><span class="line">next</span><br><span class="line">n</span><br></pre></td></tr></table></figure>
</li>
<li><p>单步运行，遇到⼦函数会进入子函数</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread step-in</span><br><span class="line">step</span><br><span class="line">s</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接执⾏完当前函数的所有代码，返回到上一个函数 </p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread step-out</span><br><span class="line">finish</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置断点</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">breakpoint set -a 函数地址</span><br><span class="line">breakpoint set -n 函数名</span><br><span class="line">breakpoint set -n test</span><br><span class="line">breakpoint set -n touchesBegan:withEvent:</span><br><span class="line">breakpoint set -n &quot;-[ViewController-touchesBegan:withEvent:]&quot;</span><br><span class="line">breakpoint set -r 正则表达式</span><br><span class="line">breakpoint set -s 动态库 -n 函数名</span><br></pre></td></tr></table></figure>
</li>
<li><p>列出所有的断点(每个断点都有⾃己的编号)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">breakpoint list</span><br></pre></td></tr></table></figure>
</li>
<li><p>禁用、启用、删除断点</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">breakpoint disable 断点编号</span><br><span class="line">breakpoint enable 断点编号 </span><br><span class="line">breakpoint delete 断点编号</span><br></pre></td></tr></table></figure>
</li>
<li><p>给断点预先设置需要执行的命令，到触发断点时，就会按顺序执行   </p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">breakpoint command add 断点编号</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看某个断点设置的命令</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">breakpoint command list 断点编号*</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除某个断点设置的命令</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">breakpoint command delete 断点编号</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找某个类型的信息</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">image lookup -t 类型</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据内存地址查找在模块中的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">image lookup -a 地址</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找某个符号或者函数的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">image lookup -n 符号或者函数名</span><br></pre></td></tr></table></figure>
</li>
<li><p>列出所加载的模块信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">image list</span><br></pre></td></tr></table></figure>
</li>
<li><p>打印出模块的偏移地址、全路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">image list -o -f</span><br></pre></td></tr></table></figure>


</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>动态调试</tag>
      </tags>
  </entry>
  <entry>
    <title>加密，签名，证书详解</title>
    <url>/2018/06/04/%E5%8A%A0%E5%AF%86%EF%BC%8C%E7%AD%BE%E5%90%8D%EF%BC%8C%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<blockquote>
<p>对加密、签名、证书的一些总结</p>
</blockquote>
<a id="more"></a>

<h4 id="1、首先来了解一下加密解密"><a href="#1、首先来了解一下加密解密" class="headerlink" title="1、首先来了解一下加密解密"></a>1、首先来了解一下加密解密</h4><ul>
<li><p>根据密钥的使用方法，可以将密码分为 2 种</p>
<ul>
<li><p>对称密码</p>
<p><img src="/images/%E5%8A%A0%E5%AF%86%EF%BC%8C%E7%AD%BE%E5%90%8D%EF%BC%8C%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%861.png" alt="加密解密1"></p>
</li>
<li><p>公钥密码（非对称密码）</p>
<p><img src="/images/%E5%8A%A0%E5%AF%86%EF%BC%8C%E7%AD%BE%E5%90%8D%EF%BC%8C%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%862.png" alt="加密解密2"></p>
</li>
</ul>
</li>
</ul>
<h5 id="对称密码（Symmetric-Cryptography）"><a href="#对称密码（Symmetric-Cryptography）" class="headerlink" title="对称密码（Symmetric Cryptography）"></a>对称密码（Symmetric Cryptography）</h5><ul>
<li><p>常见的对称密码算法有</p>
<ul>
<li>DES<ul>
<li>DES 是一种将 64bit 明文加密成 64bit 密文的对称密码算法，密钥长度是 56bit</li>
<li>规格上来说，密钥长度是 64bit，但每隔 7bit 会设置一个用于错误检查的 bit，因此密钥长度实质上是 56bit</li>
<li>由于 DES 每次只能加密 64bit 的数据，遇到比较大的数据，需要对 DES 加密进行迭代（反复）</li>
<li>目前已经可以在短时间内被破解，所以不建议使用</li>
</ul>
</li>
<li>3DES<ul>
<li>3DES，将 DES 重复 3 次所得到的一种密码算法，也叫做 3 重 DE</li>
<li>目前还被一些银行等机构使用，但处理速度不高，安全性逐渐暴露出问题</li>
</ul>
</li>
<li><strong>AES</strong><ul>
<li>取代 DES 成为新标准的一种对称密码算法</li>
<li>AES的密钥长度有 128、192、256bit 三种</li>
<li>在 2000 年时选择 Rijindael 算法作为 AES 的实现</li>
<li>目前 AES，已经逐步取代 DES、3DES，成为首选的对称密码算法</li>
<li>一般来说，我们也不应该去使用任何自制的密码算法，而是应该使用 AES，它经过了全世界密码学家所进行的高品质验证工作</li>
</ul>
</li>
</ul>
</li>
<li><p>密钥配送问题</p>
<ul>
<li><p>在使用对称密码时，一定会遇到密钥配送问题</p>
</li>
<li><p>假设，Alice 将使用对称密码加密过的消息发给了 Bob</p>
</li>
<li><p>只有将密钥发送给 Bob，Bob 才能完成解密</p>
</li>
<li><p>在发送密钥过程中，可能会被 Eve 窃取密钥，最后 Eve 也能完成解密</p>
<p><img src="/images/%E5%8A%A0%E5%AF%86%EF%BC%8C%E7%AD%BE%E5%90%8D%EF%BC%8C%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%863.png" alt="加密解密3"></p>
</li>
</ul>
</li>
<li><p>如何解决密钥配送问题</p>
<ul>
<li>事先共享密钥</li>
<li>密钥分配中心</li>
<li>Diffie-Hellman 密钥交换</li>
<li><strong>公钥密码</strong></li>
</ul>
</li>
</ul>
<h5 id="公钥密码（Public-key-Cryptography）"><a href="#公钥密码（Public-key-Cryptography）" class="headerlink" title="公钥密码（Public-key Cryptography）"></a>公钥密码（Public-key Cryptography）</h5><ul>
<li><p>在公钥密码中</p>
<ul>
<li>密钥分为加密密钥、解密密钥 2 种，它们并不是同一个密钥</li>
<li>加密密钥，一般是公开的，因此该密钥称为公钥（public key）</li>
<li>解密密钥，由消息接收者自己保管的，不能公开，因此也称为私钥（private key）</li>
<li>公钥和私钥是一一对应的，是不能单独生成的，一对公钥和密钥统称为密钥对（key pair）</li>
<li>由公钥加密的密文，必须使用与该公钥对应的私钥才能解密</li>
<li>由私钥加密的密文，必须使用与该私钥对应的公钥才能解密</li>
</ul>
</li>
<li><p>解决密钥配送问题</p>
<ul>
<li><p>由消息的接收者，生成一对公钥、私钥</p>
</li>
<li><p>将公钥发给消息的发送者</p>
</li>
<li><p>消息的发送者使用公钥加密消息</p>
<p><img src="/images/%E5%8A%A0%E5%AF%86%EF%BC%8C%E7%AD%BE%E5%90%8D%EF%BC%8C%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%864.png" alt="加密解密4"></p>
</li>
</ul>
</li>
<li><p>RSA</p>
<ul>
<li>目前使用最广泛的公钥密码算法是 RSA</li>
</ul>
</li>
</ul>
<h5 id="混合密码系统（Hybrid-Cryptosystem）"><a href="#混合密码系统（Hybrid-Cryptosystem）" class="headerlink" title="混合密码系统（Hybrid Cryptosystem）"></a>混合密码系统（Hybrid Cryptosystem）</h5><ul>
<li><p>对称密码的缺点</p>
<ul>
<li>不能很好地解决密钥配送问题</li>
</ul>
</li>
<li><p>公钥密码的缺点</p>
<ul>
<li>加密解密速度比较慢</li>
</ul>
</li>
<li><p>混合密码系统，是将对称密码和公钥密码的优势相结合的方法</p>
<ul>
<li><p>解决了公钥密码速度慢的问题</p>
</li>
<li><p>并通过公钥密码解决了对称密码的密钥配送问题</p>
</li>
</ul>
</li>
<li><p>网络上的密码通信所用的SSL/TLS都运用了混合密码系统</p>
</li>
</ul>
<h5 id="混合密码-加密"><a href="#混合密码-加密" class="headerlink" title="混合密码-加密"></a>混合密码-加密</h5><ul>
<li><p>会话密钥（session key）</p>
<ul>
<li><p>为本次通信随机生成的临时密钥</p>
</li>
<li><p>作为对称密码的密钥，用于加密消息，提高速度</p>
</li>
</ul>
</li>
<li><p>加密步骤（发送消息）</p>
<p>1.首先，消息发送者要拥有消息接收者的公钥</p>
<p>2.生成会话密钥，作为对称密码的密钥，加密消息</p>
<p>3.用消息接收者的公钥，加密会话密钥</p>
<p>4.将前 2 步生成的加密结果，一并发给消息接收者</p>
</li>
<li><p>发送出去的内容包括</p>
<ul>
<li><p>用会话密钥加密的消息（加密方法：对称密码）</p>
</li>
<li><p>用公钥加密的会话密钥（加密方法：公钥密码）</p>
</li>
</ul>
</li>
</ul>
<p><img src="/images/%E5%8A%A0%E5%AF%86%EF%BC%8C%E7%AD%BE%E5%90%8D%EF%BC%8C%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%865.png" alt="加密解密5"></p>
<h5 id="混合密码-解密"><a href="#混合密码-解密" class="headerlink" title="混合密码-解密"></a>混合密码-解密</h5><ul>
<li><p>解密步骤（收到消息）</p>
<p>1.消息接收者用自己的私钥解密出会话密钥</p>
<p>2.再用第 1 步解密出来的会话密钥，解密消息</p>
</li>
</ul>
<p><img src="/images/%E5%8A%A0%E5%AF%86%EF%BC%8C%E7%AD%BE%E5%90%8D%EF%BC%8C%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%866.png" alt="加密解密6"></p>
<h5 id="混合密码-加密解密流程"><a href="#混合密码-加密解密流程" class="headerlink" title="混合密码-加密解密流程"></a>混合密码-加密解密流程</h5><ul>
<li><p>Alice &gt;&gt;&gt;&gt;&gt; Bob</p>
<ul>
<li><p>发送过程，加密过程</p>
<p>1.Bob 先生成一对公钥、私钥</p>
<p>2.Bob 把公钥共享给 Alice</p>
<p>3.Alice 随机生成一个会话密钥（临时密钥）</p>
<p>4.Alice 用会话密钥加密需要发送的消息（使用的是对称密码加密）</p>
<p>5.Alice 用 Bob 的公钥加密会话密钥（使用的是公钥密码加密，也就是非对称密码加密）</p>
<p>6.Alice 把第 4、5 步的加密结果，一并发送给 Bob</p>
</li>
<li><p>接收过程，解密过程</p>
<p>1.Bob 利用自己的私钥解密会话密钥（使用的是公钥密码解密，也就是非对称密码解密）</p>
<p>2.Bob 利用会话密钥解密发送过来的消息（使用的是对称密码解密）</p>
</li>
</ul>
</li>
</ul>
<h4 id="2、单向散列函数（One-way-hash-function）"><a href="#2、单向散列函数（One-way-hash-function）" class="headerlink" title="2、单向散列函数（One-way hash function）"></a>2、单向散列函数（One-way hash function）</h4><ul>
<li><p>单向散列函数，又被称为消息摘要函数（message digest function），哈希函数</p>
</li>
<li><p>输出的散列值，也被称为消息摘要（message digest）、指纹（fingerprint）</p>
</li>
<li><p>单向散列函数，可以根据消息内容计算出散列值</p>
</li>
<li><p>散列值的长度和消息的长度无关，无论消息是 1bit、10M、100G，单向散列函数都会计算出固定长度的散列值</p>
<p><img src="/images/%E5%8A%A0%E5%AF%86%EF%BC%8C%E7%AD%BE%E5%90%8D%EF%BC%8C%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%867.png" alt="加密解密7"></p>
</li>
<li><p>常见的几种单向散列函数</p>
<ul>
<li>MD4、MD5<ul>
<li>产生 128bit 的散列值，MD 就是 Message Digest 的缩写，目前已经不安全</li>
<li>Mac 终端上默认可以使用 md5 命令</li>
</ul>
</li>
<li>SHA-1<ul>
<li>产生 160bit 的散列值，目前已经不安全</li>
</ul>
</li>
<li>SHA-2<ul>
<li>SHA-256、SHA-384、SHA-512，散列值长度分别是 256bit、384bit、512bit</li>
</ul>
</li>
<li>SHA-3<ul>
<li>全新标准</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="单向散列函数的特点"><a href="#单向散列函数的特点" class="headerlink" title="单向散列函数的特点"></a>单向散列函数的特点</h5><ul>
<li>根据任意长度的消息，计算出固定长度的散列值</li>
<li>计算速度快，能快速计算出散列值</li>
<li>消息不同，散列值也不同</li>
<li>具备单向性</li>
</ul>
<p><img src="/images/%E5%8A%A0%E5%AF%86%EF%BC%8C%E7%AD%BE%E5%90%8D%EF%BC%8C%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%868.png" alt="加密解密8"></p>
<p><img src="/images/%E5%8A%A0%E5%AF%86%EF%BC%8C%E7%AD%BE%E5%90%8D%EF%BC%8C%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%869.png" alt="加密解密9"></p>
<h5 id="单向散列函数的应用-–-防止数据被篡改"><a href="#单向散列函数的应用-–-防止数据被篡改" class="headerlink" title="单向散列函数的应用 – 防止数据被篡改"></a>单向散列函数的应用 – 防止数据被篡改</h5><p><img src="/images/%E5%8A%A0%E5%AF%86%EF%BC%8C%E7%AD%BE%E5%90%8D%EF%BC%8C%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%8610.png" alt="加密解密10"></p>
<h4 id="3、数字签名"><a href="#3、数字签名" class="headerlink" title="3、数字签名"></a>3、数字签名</h4><h5 id="想象以下场景"><a href="#想象以下场景" class="headerlink" title="想象以下场景"></a>想象以下场景</h5><p><img src="/images/%E5%8A%A0%E5%AF%86%EF%BC%8C%E7%AD%BE%E5%90%8D%EF%BC%8C%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%8611.png" alt="加密解密11"></p>
<ul>
<li>Alice 发的内容有可能是被篡改的，或者有人伪装成 Alice 发消息，或者就是 Alice 发的，但她可以否认</li>
<li>问题来了：Bob 如何确定这段消息的真实性？如何识别篡改、伪装、否认？</li>
<li>解决方案：数字签名</li>
</ul>
<h5 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h5><p>在数字签名技术中，有以下2种行为</p>
<ul>
<li><p>生成签名</p>
<ul>
<li>由消息的发送者完成，通过“签名密钥”生成</li>
</ul>
</li>
<li><p>验证签名</p>
<ul>
<li>由消息的接收者完成，通过“验证密钥”验</li>
</ul>
</li>
</ul>
<p>那么问题来了：如何能保证这个签名是消息发送者自己签的？</p>
<ul>
<li>用消息发送者的私钥进行签名</li>
</ul>
<p><img src="/images/%E5%8A%A0%E5%AF%86%EF%BC%8C%E7%AD%BE%E5%90%8D%EF%BC%8C%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%8612.png" alt="加密解密12"></p>
<pre><code>在公钥密码中，任何人都可以使用公钥进行加密</code></pre><p><img src="/images/%E5%8A%A0%E5%AF%86%EF%BC%8C%E7%AD%BE%E5%90%8D%EF%BC%8C%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%8613.png" alt="加密解密13"></p>
<pre><code>在数字签名中，任何人都可以使用公钥验证签名</code></pre><h5 id="数字签名的过程"><a href="#数字签名的过程" class="headerlink" title="数字签名的过程"></a>数字签名的过程</h5><ul>
<li><p>Alice 生成密钥对，将公钥发送给 Bob</p>
</li>
<li><p>Alice 用自己的私钥进行加密（生成签名）</p>
</li>
<li><p>Alice 将消息和签名发送给 Bob</p>
</li>
<li><p>Bob 用公钥验证签名</p>
<p><img src="/images/%E5%8A%A0%E5%AF%86%EF%BC%8C%E7%AD%BE%E5%90%8D%EF%BC%8C%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%8614.png" alt="加密解密14"></p>
</li>
</ul>
<h5 id="数字签名-–-疑惑"><a href="#数字签名-–-疑惑" class="headerlink" title="数字签名 – 疑惑"></a>数字签名 – 疑惑</h5><ul>
<li>如果有人篡改了文件内容或者签名内容，会是什么结果？<ul>
<li>签名验证失败，证明内容被篡改</li>
</ul>
</li>
<li>数字签名不能保证机密性？<ul>
<li>数字签名的作用不是为了保证机密性，仅仅是为了能够识别内容有没有被篡改</li>
</ul>
</li>
<li>数字签名的作用<ul>
<li>确认消息的完整性</li>
<li>识别消息是否被篡改</li>
</ul>
</li>
</ul>
<h5 id="数字签名无法解决的问题"><a href="#数字签名无法解决的问题" class="headerlink" title="数字签名无法解决的问题"></a>数字签名无法解决的问题</h5><ul>
<li><p>要正确使用签名，前提是</p>
<ul>
<li>用于验证签名的公钥必须属于真正的发送者</li>
</ul>
</li>
<li><p>如果遭遇了中间人攻击，那么</p>
<ul>
<li>公钥将是伪造的</li>
<li>数字签名将失效</li>
</ul>
</li>
<li><p>所以在验证签名之前，首先得先验证公钥的合法性</p>
</li>
<li><p>如何验证公钥的合法性？</p>
<ul>
<li>证书</li>
</ul>
</li>
</ul>
<p><img src="/images/%E5%8A%A0%E5%AF%86%EF%BC%8C%E7%AD%BE%E5%90%8D%EF%BC%8C%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%8615.png" alt="加密解密15"></p>
<h4 id="4、证书"><a href="#4、证书" class="headerlink" title="4、证书"></a>4、证书</h4><ul>
<li><p>密码学中的证书，全称叫公钥证书（Public-key Certificate，PKC），跟驾驶证类似</p>
<ul>
<li><p>里面有姓名、邮箱等个人信息，以及此人的公钥</p>
</li>
<li><p>并由认证机构（Certificate Authority，CA）施加数字签名</p>
</li>
</ul>
</li>
<li><p>CA就是能够认定“公钥确实属于此人”并能够生成数字签名的个人或者组织</p>
<ul>
<li><p>有国际性组织、政府设立的组织</p>
</li>
<li><p>有通过提供认证服务来盈利的企业</p>
</li>
<li><p>个人也可以成立认证机构</p>
</li>
</ul>
</li>
</ul>
<h5 id="证书的利用"><a href="#证书的利用" class="headerlink" title="证书的利用"></a>证书的利用</h5><p><img src="/images/%E5%8A%A0%E5%AF%86%EF%BC%8C%E7%AD%BE%E5%90%8D%EF%BC%8C%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%8616.png" alt="加密解密16"></p>
<h5 id="证书的注册和下载"><a href="#证书的注册和下载" class="headerlink" title="证书的注册和下载"></a>证书的注册和下载</h5><p><img src="/images/%E5%8A%A0%E5%AF%86%EF%BC%8C%E7%AD%BE%E5%90%8D%EF%BC%8C%E8%AF%81%E4%B9%A6%E8%AF%A6%E8%A7%A3/%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%8617.png" alt="加密解密17"></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>对RunLoop的一些看法</title>
    <url>/2018/04/12/%E5%AF%B9RunLoop%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9C%8B%E6%B3%95/</url>
    <content><![CDATA[<h3 id="RunLoop-介绍"><a href="#RunLoop-介绍" class="headerlink" title="RunLoop 介绍"></a>RunLoop 介绍</h3><p>运行循环，在程序运行过程中循环做一些事情，如果没有 Runloop 程序执行完毕就会立即退出，如果有Runloop程序会一直运行，并且时时刻刻在等待用户的输入操作。RunLoop 可以在需要的时候自己跑起来运行，在没有操作的时候就停下来休息。充分节省 CPU 资源，提高程序性能。</p>
<a id="more"></a>

<h4 id="1、RunLoop-的基本作用"><a href="#1、RunLoop-的基本作用" class="headerlink" title="1、RunLoop 的基本作用"></a>1、RunLoop 的基本作用</h4><ul>
<li>保持程序的持续运行</li>
<li>处理 App 中的各种事件（比如触摸事件、定时器事件等）</li>
<li>节省 CPU 资源，提高程序性能：该做事时做事，该休息时休息</li>
</ul>
<hr>
<h4 id="2、RunLoop-对象"><a href="#2、RunLoop-对象" class="headerlink" title="2、RunLoop 对象"></a>2、RunLoop 对象</h4><ul>
<li><p>iOS 中有 2 套 API 来访问和使用 RunLoop</p>
</li>
<li><p>Foundation：NSRunLoop</p>
</li>
<li><p>Core Foundation：CFRunLoopRef</p>
</li>
<li><p>NSRunLoop 和 CFRunLoopRef 都代表着 RunLoop 对象</p>
</li>
<li><p>NSRunLoop 是基于 CFRunLoopRef 的一层 OC 包装</p>
</li>
<li><p><a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">CFRunLoopRef</a> 是开源的</p>
</li>
</ul>
<hr>
<h4 id="3、RunLoop-与线程"><a href="#3、RunLoop-与线程" class="headerlink" title="3、RunLoop 与线程"></a>3、RunLoop 与线程</h4><ul>
<li>每条线程都有唯一的一个与之对应的 RunLoop 对象</li>
<li>RunLoop 保存在一个全局的 Dictionary 里，线程作为 key，RunLoop 作为 value</li>
<li>线程刚创建时并没有 RunLoop 对象，RunLoop 会在第一次获取它时创建</li>
<li>RunLoop 会在线程结束时销毁</li>
<li>主线程的 RunLoop 已经自动获取（创建），子线程默认没有开启 RunLoop</li>
</ul>
<hr>
<h4 id="4、获取RunLoop对象"><a href="#4、获取RunLoop对象" class="headerlink" title="4、获取RunLoop对象"></a>4、获取RunLoop对象</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Foundation</span></span><br><span class="line"><span class="comment">// 获得当前线程的 RunLoop 对象</span></span><br><span class="line">[<span class="built_in">NSRunLoop</span> currentRunLoop]; </span><br><span class="line"><span class="comment">// 获得主线程的 RunLoop 对象</span></span><br><span class="line">[<span class="built_in">NSRunLoop</span> mainRunLoop]; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Core Foundation</span></span><br><span class="line"><span class="comment">// 获得当前线程的 RunLoop 对象 </span></span><br><span class="line"><span class="built_in">CFRunLoopGetCurrent</span>(); </span><br><span class="line"><span class="comment">// 获得主线程的 RunLoop 对象</span></span><br><span class="line"><span class="built_in">CFRunLoopGetMain</span>();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5、RunLoop-相关的类"><a href="#5、RunLoop-相关的类" class="headerlink" title="5、RunLoop 相关的类"></a>5、RunLoop 相关的类</h4><p>Core Foundation 中关于 RunLoop 的5个类</p>
<ul>
<li>CFRunLoopRef</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __CFRunLoop * <span class="built_in">CFRunLoopRef</span></span><br><span class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</span><br><span class="line">    pthread_t _pthread;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems;</span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>CFRunLoopModeRef</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __CFRunLoopMode * <span class="built_in">CFRunLoopModeRef</span></span><br><span class="line"><span class="keyword">struct</span> __CFRunLoopMode &#123;</span><br><span class="line">    <span class="built_in">CFStringRef</span> _name;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources0;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1;</span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers;</span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>
<p><img src="/images/%E5%AF%B9RunLoop%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9C%8B%E6%B3%95/RunLoop.png" alt="RunLoop"></p>
<hr>
<h4 id="6、CFRunLoopModeRef"><a href="#6、CFRunLoopModeRef" class="headerlink" title="6、CFRunLoopModeRef"></a>6、CFRunLoopModeRef</h4><ul>
<li>CFRunLoopModeRef 代表 RunLoop 的运行模式</li>
</ul>
<p>一个 RunLoop 包含若干个 Mode，每个 Mode 又包含若干个 Source0/Source1/Timer/Observer</p>
<ul>
<li>RunLoop 启动时只能选择其中一个 Mode，作为 currentMode</li>
<li>如果需要切换 Mode，只能退出当前 Loop，再重新选择一个 Mode 进入</li>
<li>不同组的 Source0/Source1/Timer/Observer 能分隔开来，互不影响</li>
<li>如果 Mode 里没有任何 Source0/Source1/Timer/Observer，RunLoop 会立马退出</li>
<li>系统默认注册了 5 个 Mode</li>
<li>kCFRunLoopDefaultMode（NSDefaultRunLoopMode）：App 的默认 Mode，通常主线程是在这个 Mode 下运行的</li>
<li>UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</li>
<li>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用</li>
<li>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到</li>
<li>kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用</li>
</ul>
<hr>
<h4 id="7、RunLoop的运行逻辑"><a href="#7、RunLoop的运行逻辑" class="headerlink" title="7、RunLoop的运行逻辑"></a>7、RunLoop的运行逻辑</h4><ul>
<li><p>Source0</p>
<ul>
<li>触摸事件处理</li>
<li>performSelector:onThread:</li>
</ul>
</li>
<li><p>Source1</p>
<ul>
<li>基于 Port 的线程间通信</li>
<li>系统事件捕捉</li>
</ul>
</li>
<li><p>Timers</p>
<ul>
<li>NSTimer</li>
<li>performSelector:withObject:afterDelay:</li>
</ul>
</li>
<li><p>Observers</p>
<ul>
<li>用于监听 RunLoop 的状态</li>
<li>UI刷新（BeforeWaiting）</li>
<li>Autorelease pool（BeforeWaiting）</li>
</ul>
</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="/images/%E5%AF%B9RunLoop%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9C%8B%E6%B3%95/RunLoop_Logic.png" alt="RunLoop_Logic"></h2><h4 id="7、RunLoop在实际开中的应用"><a href="#7、RunLoop在实际开中的应用" class="headerlink" title="7、RunLoop在实际开中的应用"></a>7、RunLoop在实际开中的应用</h4><ul>
<li>控制线程生命周期（线程保活）</li>
<li>解决NSTimer在滑动时停止工作的问题</li>
<li>监控应用卡顿</li>
<li>性能优化</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>RunLoop</tag>
      </tags>
  </entry>
  <entry>
    <title>金额字符串格式化</title>
    <url>/2018/03/25/%E9%87%91%E9%A2%9D%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<p>在一些金融类的 App 中，对于表示金额类的字符串，通常需要进行格式化后再显示出来。例如：</p>
</blockquote>
<ul>
<li><code>0</code> –&gt; <code>0.00</code></li>
<li><code>123</code> –&gt; <code>123.00</code></li>
<li><code>123.456</code> –&gt; <code>123.46</code></li>
<li><code>102000</code> –&gt; <code>102,000.00</code></li>
<li><code>10204500</code> –&gt; <code>10,204,500.00</code></li>
</ul>
<p>它的规则如下：</p>
<p><strong>个位数起每隔三位数字添加一个逗号，同时保留两位小数</strong>，也称为“千分位格式”。</p>
<p>苹果提供了 <code>NSNumberFormatter</code> 用来处理 <code>NSString</code> 和 <code>NSNumber</code> 之间的转化，可以满足基本的数字形式的格式化。我们通过设置 <code>NSNumberFormatter</code> 的 <code>numberStyle</code> 和 <code>positiveFormat</code> 属性，即可实现上述功能，非常简洁，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)formatDecimalNumber:(<span class="built_in">NSString</span> *)string &#123;</span><br><span class="line">    <span class="keyword">if</span> (!string || string.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSNumber</span> *number = @([string doubleValue]);</span><br><span class="line">    <span class="built_in">NSNumberFormatter</span> *formatter = [[<span class="built_in">NSNumberFormatter</span> alloc] init];</span><br><span class="line">    formatter.numberStyle = kCFNumberFormatterDecimalStyle;</span><br><span class="line">    formatter.positiveFormat = <span class="string">@"###,##0.00"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *amountString = [formatter stringFromNumber:number];</span><br><span class="line">    <span class="keyword">return</span> amountString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 <code>NSNumberFormatter</code> 更详细的用法，可以参考这篇文章的介绍：<a href="https://www.jianshu.com/p/95952b145a8e" target="_blank" rel="noopener">NSNumberFormatter 介绍和用法</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>KVO 到底在干什么？</title>
    <url>/2018/03/21/KVO%E5%88%B0%E5%BA%95%E5%9C%A8%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<h4 id="一、KVO-的基本使用"><a href="#一、KVO-的基本使用" class="headerlink" title="一、KVO 的基本使用"></a>一、KVO 的基本使用</h4><p>首先我们来看一下 <code>KVO</code> 的基本使用，<code>KVO</code> 的全称 <code>Key-Value Observing</code>，俗称“键值监听”，可以用于监听某个对象属性值的改变。<br>  <a id="more"></a></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    Person *p1 = [[Person alloc] init];</span><br><span class="line">    Person *p2 = [[Person alloc] init];</span><br><span class="line">    p1.age = <span class="number">10</span>;</span><br><span class="line">    p2.age = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// self 监听 p1 的 age 属性</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    [p1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span> options:options context:<span class="literal">nil</span>];</span><br><span class="line">    p1.age = <span class="number">30</span>;</span><br><span class="line">    p2.age = <span class="number">40</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSKeyValueChangeKey</span>,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"监听到%@的%@改变了%@"</span>, object, keyPath,change);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印内容</span></span><br><span class="line">监听到&lt;Person: <span class="number">0x600000108640</span>&gt;的age改变了&#123;</span><br><span class="line">    kind = <span class="number">1</span>;</span><br><span class="line">    new = <span class="number">30</span>;</span><br><span class="line">    old = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上述代码中可以看出，在添加监听之后，<code>age</code> 属性的值在发生改变时，就会通知到监听者，执行监听者的  <code>observeValueForKeyPath</code> 方法。</p>
<h4 id="二、探寻-KVO-原理"><a href="#二、探寻-KVO-原理" class="headerlink" title="二、探寻 KVO 原理"></a>二、探寻 KVO 原理</h4><ul>
<li><p>通过上述代码我们发现，一旦 <code>age</code> 属性的值发生改变时，就会通知到监听者，并且我们知道赋值操作都是调用属性的 <code>set</code> 方法，我们可以来到 <code>Person</code> 类中重写 <code>age</code> 的 <code>set</code> 方法，观察是否是 <code>KVO</code> 在 <code>set</code> 方法内部做了一些操作来通知监听者。</p>
</li>
<li><p>我们发现即使重写了 <code>set</code> 方法，<code>p1</code> 对象和 <code>p2</code> 对象调用同样的 <code>set</code> 方法，但是我们发现 <code>p1</code>除了调用 <code>set</code> 方法之外还会另外执行监听器的 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法。</p>
</li>
<li><p>这说明 <code>KVO</code> 在运行时获取对 <code>p1</code> 对象做了一些改变。相当于在程序运行过程中，对 <code>p1</code> 对象做了一些变化，使得 <code>p1</code> 对象在调用 <code>setAge:</code> 方法的时候可能做了一些额外的操作，所以问题出在对象身上，两个对象在内存中肯定不一样，两个对象本质上也不一样。</p>
</li>
</ul>
<h4 id="三、KVO-底层实现分析"><a href="#三、KVO-底层实现分析" class="headerlink" title="三、KVO 底层实现分析"></a>三、KVO 底层实现分析</h4><ul>
<li>首先我们来看一下 <code>p1</code> 和 <code>p2</code> 在 <code>addObserver</code> 方法 前后的 <code>isa</code> 分别是什么</li>
</ul>
<p><img src="/images/KVO%E5%88%B0%E5%BA%95%E5%9C%A8%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F/KVO.png" alt="KVO"></p>
<ul>
<li><p>通过上图我们发现，<code>p1</code> 对象执行过 <code>addObserver</code> 操作之后，<code>p1</code> 对象的 <code>isa</code> 指针由之前的指向类对象 <code>Person</code> 变为指向 <code>NSKVONotifyin_Person</code> 类对象，而 <code>p2</code> 对象没有任何改变。也就是说一旦 <code>p1</code> 对象添加了 <code>KVO</code> 监听以后，其 <code>isa</code> 指针就会发生变化，因此 <code>set</code> 方法的执行效果就不一样了。</p>
</li>
<li><p>那么我们先来观察 <code>p2</code> 对象在内容中是如何存储的，然后对比 <code>p2</code> 来观察 <code>p1</code> 。<br>首先我们知道，<code>p2</code> 在调用 <code>setAge:</code> 方法的时候，首先会通过 <code>p2</code> 对象中的 <code>isa</code> 指针找到 <code>Person</code> 类对象，然后在类对象中找到 <code>setAge:</code> 方法。然后找到方法对应的实现。如下图所示</p>
<p><img src="/images/KVO%E5%88%B0%E5%BA%95%E5%9C%A8%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F/person_isa.png" alt="person_isa"></p>
</li>
<li><p>但是刚才我们发现 <code>p1</code> 对象的 <code>isa</code> 指针在经过 <code>KVO</code> 监听之后已经指向了 <code>NSKVONotifyin_Person</code> 类对象，<code>NSKVONotifyin_Person</code> 其实是 <code>Person</code> 的子类，那么也就是说其 <code>superclass</code> 指针是指向 <code>Person</code> 类对象的，<code>NSKVONotifyin_Person</code> 是 runtime 在运行时生成的。那么 <code>p1</code> 对象在调用 <code>setAge:</code> 方法的时候，肯定会根据 <code>p1</code> 的 <code>isa</code> 找到 <code>NSKVONotifyin_Person</code>，在 <code>NSKVONotifyin_Person</code> 中找 <code>setAge:</code> 方法的实现。</p>
</li>
<li><p><code>NSKVONotifyin_Person</code> 中的 <code>setAge:</code> 方法中其实调用了 <code>Fundation</code> 框架中 C 语言函数 <code>_NSsetIntValueAndNotify</code>，<code>_NSsetIntValueAndNotify</code> 内部做的操作相当于:</p>
<ul>
<li>首先调用 willChangeValueForKey:</li>
<li>之后调用父类的 setAge: 方法对成员变量赋值</li>
<li>最后调用 didChangeValueForKey:</li>
<li>didChangeValueForKey: 中会调用监听器的监听方法，最终来到监听者的 observeValueForKeyPath:ofObject:change:context: 方法中</li>
</ul>
</li>
</ul>
<h4 id="四、NSKVONotifyin-Person-内部结构是怎样的？"><a href="#四、NSKVONotifyin-Person-内部结构是怎样的？" class="headerlink" title="四、NSKVONotifyin_Person 内部结构是怎样的？"></a>四、NSKVONotifyin_Person 内部结构是怎样的？</h4><p>首先我们知道，<code>NSKVONotifyin_Person</code> 作为 <code>Person</code> 的子类，其 <code>superclass</code> 指针指向 <code>Person</code> 类，并且  <code>NSKVONotifyin_Person</code> 内部一定对 <code>setAge:</code> 方法做了单独的实现，那么 <code>NSKVONotifyin_Person</code> 同 <code>Person</code> 类的差别可能就在于其内存储的对象方法及实现不同。<br>我们通过 <code>runtime</code> 分别打印 <code>Person</code> 类对象和 <code>NSKVONotifyin_Person</code> 类对象内存储的对象方法</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad </span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    </span><br><span class="line">    Person *p1 = [[Person alloc] init];</span><br><span class="line">    p1.age = <span class="number">10</span>;</span><br><span class="line">    Person *p2 = [[Person alloc] init];</span><br><span class="line">    p2.age = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// self 监听 p1 的 age 属性</span></span><br><span class="line">    <span class="built_in">NSKeyValueObservingOptions</span> options = <span class="built_in">NSKeyValueObservingOptionNew</span> | <span class="built_in">NSKeyValueObservingOptionOld</span>;</span><br><span class="line">    [p1 addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span> options:options context:<span class="literal">nil</span>];</span><br><span class="line">    [<span class="keyword">self</span> printMethods: object_getClass(p2)];</span><br><span class="line">    [<span class="keyword">self</span> printMethods: object_getClass(p1)];</span><br><span class="line">    [p1 removeObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@"age"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)printMethods:(Class)cls</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count ;</span><br><span class="line">    Method *methods = class_copyMethodList(cls, &amp;count);</span><br><span class="line">    <span class="built_in">NSMutableString</span> *methodNames = [<span class="built_in">NSMutableString</span> string];</span><br><span class="line">    [methodNames appendFormat:<span class="string">@"%@ - "</span>, cls];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span> ; i &lt; count; i++) &#123;</span><br><span class="line">        Method method = methods[i];</span><br><span class="line">        <span class="built_in">NSString</span> *methodName  = <span class="built_in">NSStringFromSelector</span>(method_getName(method));</span><br><span class="line"></span><br><span class="line">        [methodNames appendString: methodName];</span><br><span class="line">        [methodNames appendString:<span class="string">@" "</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,methodNames);</span><br><span class="line">    free(methods);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打印内容</span></span><br><span class="line">Person - setAge: age</span><br><span class="line"><span class="built_in">NSKVONotifying_Person</span> - setAge: <span class="keyword">class</span> dealloc _isKVOA</span><br></pre></td></tr></table></figure>

<p>通过上述代码我们发现 <code>NSKVONotifyin_Person</code> 中有 <code>4</code> 个对象方法。分别为 <code>setAge:</code>  <code>class</code> <code>dealloc</code> <code>_isKVOA</code>，那么至此我们可以知道 <code>NSKVONotifyin_Person</code> 的内存结构以及方法调用顺序。</p>
<p><img src="/images/KVO%E5%88%B0%E5%BA%95%E5%9C%A8%E5%B9%B2%E4%BB%80%E4%B9%88%EF%BC%9F/NSKVONotifyin_Person.png" alt="NSKVONotifyin_Person"></p>
<ul>
<li><p>这里 <code>NSKVONotifyin_Person</code> 重写 <code>class</code> 方法是为了隐藏 <code>NSKVONotifyin_Person</code>，使其不被外界所看到。我们在 <code>p1</code> 添加过KVO监听之后，分别打印 <code>p1</code> 和 <code>p2</code> 对象的 <code>class</code> 可以发现他们都返回 <code>Person</code>。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@,%@"</span>,[p1 <span class="keyword">class</span>],[p2 <span class="keyword">class</span>]);</span><br><span class="line"><span class="comment">// 打印结果 Person,Person</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果 <code>NSKVONotifyin_Person</code> 不重写 <code>class</code> 方法，那么当对象要调用 <code>class</code> 对象方法的时候就会一直向上找来到 <code>Nsobject</code>，而 <code>Nsobect</code> 的 <code>class</code> 的实现大致为返回自己 <code>isa</code> 指向的类，返回 <code>p1</code> 的 <code>isa</code> 指向的类那么打印出来的类就是 <code>NSKVONotifyin_Person</code>，但是 Apple 爸爸不希望将 <code>NSKVONotifyin_Person</code> 类暴露出来，并且不希望我们知道 <code>NSKVONotifyin_Person</code> 内部实现，所以在内部重写了<code>class 对象方法</code>，直接返回 <code>Person</code> 类，所以外界在调用 <code>p1</code> 的 <code>class 对象方法</code>时，是 <code>Person</code> 类。这样 <code>p1</code> 给外界的感觉 <code>p1</code> 还是 <code>Person</code> 类，并不知道 <code>NSKVONotifyin_Person</code> 子类的存在。</p>
<p>那么我们可以猜测 <code>NSKVONotifyin_Person</code>内重写的 <code>class</code> 内部实现大致为</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (Class)<span class="keyword">class</span> </span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 得到类对象，再找到类对象父类</span></span><br><span class="line">     <span class="keyword">return</span> class_getSuperclass(object_getClass(<span class="keyword">self</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="五、验证-didChangeValueForKey-内部会调用-observer-的-observeValueForKeyPath-ofObject-change-context-方法"><a href="#五、验证-didChangeValueForKey-内部会调用-observer-的-observeValueForKeyPath-ofObject-change-context-方法" class="headerlink" title="五、验证 didChangeValueForKey: 内部会调用 observer 的 observeValueForKeyPath:ofObject:change:context: 方法"></a>五、验证 <strong>didChangeValueForKey:</strong> 内部会调用 observer 的 <strong>observeValueForKeyPath:ofObject:change:context:</strong> 方法</h4><ul>
<li><p>我们在 <code>Person</code> 类中重写 <code>willChangeValueForKey:</code> 和 <code>didChangeValueForKey:</code> 方法，模拟它们的实现</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setAge:(<span class="keyword">int</span>)age</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"setAge:"</span>);</span><br><span class="line">    _age = age;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)willChangeValueForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"willChangeValueForKey: - begin"</span>);</span><br><span class="line">    [<span class="keyword">super</span> willChangeValueForKey:key];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"willChangeValueForKey: - end"</span>);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)didChangeValueForKey:(<span class="built_in">NSString</span> *)key</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didChangeValueForKey: - begin"</span>);</span><br><span class="line">    [<span class="keyword">super</span> didChangeValueForKey:key];</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"didChangeValueForKey: - end"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打印内容</span></span><br><span class="line">setAge:</span><br><span class="line">setAge:</span><br><span class="line">willChangeValueForKey: - begin</span><br><span class="line">willChangeValueForKey: - end</span><br><span class="line">setAge:</span><br><span class="line">didChangeValueForKey: - begin</span><br><span class="line">监听到&lt;Person: <span class="number">0x6000032f4260</span>&gt;的age改变了&#123;</span><br><span class="line">    kind = <span class="number">1</span>;</span><br><span class="line">    new = <span class="number">30</span>;</span><br><span class="line">    old = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">didChangeValueForKey: - end</span><br><span class="line">setAge:</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过上面的打印内容，我们知道 <code>didChangeValueForKey:</code> 内部确实会调用 <code>observer</code> 的 <code>observeValueForKeyPath:ofObject:change:context:</code> 方法，验证了之前的观点。</p>
</li>
</ul>
<h4 id="六、总结（KVO的本质是什么？）"><a href="#六、总结（KVO的本质是什么？）" class="headerlink" title="六、总结（KVO的本质是什么？）"></a>六、总结（KVO的本质是什么？）</h4><ul>
<li>利用 <code>RuntimeAPI</code> 动态生成一个子类，并且让 <code>instance</code> 对象的 <code>isa</code> 指向这个全新的子类<code>（NSKVONotifying_XXX）</code></li>
<li>当修改 <code>instance</code> 对象的属性时，会调用 <code>Foundation</code> 的 <code>_NSSetXXXValueAndNotify</code> 函数</li>
<li>子类拥有自己的set方法实现，内部会调用<ul>
<li>willChangeValueForKey:</li>
<li>原来的 setter 方法</li>
<li>didChangeValueForKey: 这个方法内部又会调用监听器(observe)的监听方法（observeValueForKeyPath:ofObject:change:context:）</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>KVO</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈二分查找</title>
    <url>/2018/01/23/%E6%B5%85%E8%B0%88%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<blockquote>
<p>二分查找是一种算法，其输入是一个有序的元素列表（必须有序的原因稍后解释）。如果要查找的元素包含在列表中，二分查找返回其位置；否则返回null 。</p>
</blockquote>
<a id="more"></a>

<h4 id="1-下面是一个例子："><a href="#1-下面是一个例子：" class="headerlink" title="1. 下面是一个例子："></a>1. 下面是一个例子：</h4><h6 id="我随便想一个-1～100-的数字，你的目标是以最少的次数猜到这个数字。你每次猜测后，我会说小了、大了或对了。假设你从-1-开始依次往上猜，每次猜测都只能排除一个数字。如果我想的数字是-99，你得猜-99-次才能猜到！"><a href="#我随便想一个-1～100-的数字，你的目标是以最少的次数猜到这个数字。你每次猜测后，我会说小了、大了或对了。假设你从-1-开始依次往上猜，每次猜测都只能排除一个数字。如果我想的数字是-99，你得猜-99-次才能猜到！" class="headerlink" title="我随便想一个 1～100 的数字，你的目标是以最少的次数猜到这个数字。你每次猜测后，我会说小了、大了或对了。假设你从 1 开始依次往上猜，每次猜测都只能排除一个数字。如果我想的数字是 99，你得猜 99 次才能猜到！"></a>我随便想一个 1～100 的数字，你的目标是以最少的次数猜到这个数字。你每次猜测后，我会说小了、大了或对了。假设你从 1 开始依次往上猜，每次猜测都只能排除一个数字。如果我想的数字是 99，你得猜 99 次才能猜到！</h6><h4 id="更佳的查找方式（二分查找）"><a href="#更佳的查找方式（二分查找）" class="headerlink" title="更佳的查找方式（二分查找）"></a>更佳的查找方式（二分查找）</h4><p>我们直接上代码</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(list: [Int], item: Int)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> low = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> high = list.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> low &lt;= high &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = (low + high) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">let</span> guess = list[mid]</span><br><span class="line">        <span class="keyword">if</span> guess == item &#123; <span class="keyword">return</span> mid &#125;</span><br><span class="line">        <span class="keyword">if</span> guess &gt; item &#123;</span><br><span class="line">            high = mid - <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myList = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">let</span> result = binarySearch(list: myList, item: <span class="number">7</span>) <span class="comment">// result is 3</span></span><br></pre></td></tr></table></figure>
<h4 id="2-运行时间"><a href="#2-运行时间" class="headerlink" title="2. 运行时间"></a>2. 运行时间</h4><ul>
<li>每次介绍算法时，我都将讨论其运行时间。一般而言，应选择效率最高的算法，以最大限度地减少运行时间或占用空间。回到前面的二分查找。使用它可节省多少时间呢？简单查找逐个地检查数字，如果列表包含 100 个数字，最多需要猜 100 次。如果列表包含 40 亿个数字，最多需要猜 40 亿次。换言之，最多需要猜测的次数与列表长度相同，这被称为<strong>线性时间(linear time)</strong>。  </li>
<li>二分查找则不同。如果列表包含 100 个元素，最多要猜 7 次；如果列表包含 40 亿个数字，最多需猜 32 次。厉害吧？二分查找的运行时间为<strong>对数时间(或log时间)</strong>。</li>
</ul>
<h4 id="3-大O表示法"><a href="#3-大O表示法" class="headerlink" title="3. 大O表示法"></a>3. 大O表示法</h4><blockquote>
<p>大O表示法指出了算法有多快。例如，假设列表包含 n 个元素。简单查找需要检查每个元素，因此需要执行 n 次操作。使用 <strong>大O</strong> 表示法，这个运行时间为 O (n )。单位秒呢？没有—— <strong>大O</strong> 表示法指的并非以秒为单位的速度。<br><strong>大O</strong> 表示法让你能够比较操作数，它指出了算法运行时间的增速 。</p>
</blockquote>
<h5 id="3-1-大O表示法让你能够比较操作数，它指出了算法运行时间的增速"><a href="#3-1-大O表示法让你能够比较操作数，它指出了算法运行时间的增速" class="headerlink" title="3.1 大O表示法让你能够比较操作数，它指出了算法运行时间的增速"></a>3.1 大O表示法让你能够比较操作数，它指出了算法运行时间的增速</h5><p>下面按从快到慢的顺序列出了你经常会遇到的 5 种 大O 运行时间。</p>
<ul>
<li>O (log n )，也叫对数时间 ，这样的算法包括二分查找。</li>
<li>O (n )，也叫线性时间 ，这样的算法包括简单查找。</li>
<li>O (n * log n )，这样的算法包括快速排序(一种速度较快的排序算法)。</li>
<li>O (n 2 )，这样的算法包括选择排序(一种速度较慢的排序算法)。</li>
<li>O (n !)，这样的算法包括旅行商问题的解决方案(一种非常慢的算法)</li>
</ul>
<h4 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h4><ul>
<li>二分查找的速度比简单查找快得多</li>
<li>O (log n ) 比 O (n ) 快。需要搜索的元素越多，前者比后者就快得越多。</li>
<li>算法运行时间并不以秒为单位。</li>
<li>算法运行时间是从其增速的角度度量的。</li>
<li>算法运行时间用 大O 表示法表示。</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title>CocoaPods最简单成功安装实例</title>
    <url>/2017/09/23/CocoaPods%E6%9C%80%E7%AE%80%E5%8D%95%E6%88%90%E5%8A%9F%E5%AE%89%E8%A3%85%E5%AE%9E%E4%BE%8B/</url>
    <content><![CDATA[<h4 id="一、CocoaPods介绍"><a href="#一、CocoaPods介绍" class="headerlink" title="一、CocoaPods介绍"></a>一、CocoaPods介绍</h4><ul>
<li>CocoaPods 是 iOS 开发中的第三方库管理的工具。目的是让我们能自动化的、集中的、直观的管理第三方开源库。</li>
<li>CocoaPods 能够自动解决库与库之间的依赖关系，下载库的源代码。并创建一个 Xcode 的 workspace 来将这些第三方库和我们的工程连接起来，供我们开发使用。<a id="more"></a>

</li>
</ul>
<h4 id="二、安装CocoaPods"><a href="#二、安装CocoaPods" class="headerlink" title="二、安装CocoaPods"></a>二、安装CocoaPods</h4><p>1、将 gem 升级为最新版本</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">sudo gem update --system</span><br></pre></td></tr></table></figure>

<p>2、因为 Ruby 的软件源 rubygems.org 被屏蔽了，所以要更换源</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gem sources --add https:&#x2F;&#x2F;gems.ruby-china.com&#x2F; --remove https:&#x2F;&#x2F;rubygems.org&#x2F;</span><br></pre></td></tr></table></figure>
<p>3、接着执行下面命令，确保只有 gems.ruby-china.com （确保旧版本镜像都要移除，比如原先如果有淘宝镜像也要删除。）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gem sources -l</span><br></pre></td></tr></table></figure>
<p>​                       <img src="/images/CocoaPods%E6%9C%80%E7%AE%80%E5%8D%95%E6%88%90%E5%8A%9F%E5%AE%89%E8%A3%85%E5%AE%9E%E4%BE%8B/gem_source.png" alt="gem_source"></p>
<p>4、运行如下命令安装 CocoaPods</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gem install -n &#x2F;usr&#x2F;local&#x2F;bin cocoapods</span><br></pre></td></tr></table></figure>
<p>5、接着执行如下命令，如果没有报错，就说明一切安装成功了。（这个执行后要等上一段时间，Cocoapods 在将它的信息下载到 ~/.cocoapods 里。大概有100多兆。）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod setup</span><br></pre></td></tr></table></figure>
<p>6、下载中如果不放心，可以 command + T 新建一个终端窗口分别输入下面两条命令查看下载了多少</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~&#x2F;.cocoapods</span><br><span class="line">du -sh</span><br></pre></td></tr></table></figure>
<p>7、安装后执行如下命令查看版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pod --version</span><br></pre></td></tr></table></figure>
<p><img src="/images/CocoaPods%E6%9C%80%E7%AE%80%E5%8D%95%E6%88%90%E5%8A%9F%E5%AE%89%E8%A3%85%E5%AE%9E%E4%BE%8B/pod_version.png" alt="pod_version"></p>
<p>8、以后要更新升级 CocoaPods，执行如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gem update cocoapods</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>CacoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发你可能用的上的开源工具</title>
    <url>/2017/08/22/iOS%E5%BC%80%E5%8F%91%E4%BD%A0%E5%8F%AF%E8%83%BD%E7%94%A8%E7%9A%84%E4%B8%8A%E7%9A%84%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<ul>
<li><p>IBAnimatable 是一个帮助我们在 Interface Builder 和 Swift Playground 里面设计 UI, 交互, 导航模式, 换场和动画的开源库。</p>
<p><a href="https://github.com/IBAnimatable/IBAnimatable" target="_blank" rel="noopener">https://github.com/IBAnimatable/IBAnimatable</a></p>
<a id="more"></a>
</li>
<li><p>FSPagerView是一个优雅的屏幕幻灯片库。<br><a href="https://github.com/WenchaoD/FSPagerView" target="_blank" rel="noopener">https://github.com/WenchaoD/FSPagerView</a></p>
</li>
<li><p>非常好用的帮助处理 Date 相关的库。灵活运用了 swift 的重载操作符、扩展等特性，使得时间可以直观的进行算术运算：比较大小，直接加减等。常见的时间也字符串的转换也做了良好的支持。<br><a href="https://github.com/malcommac/SwiftDate" target="_blank" rel="noopener">https://github.com/malcommac/SwiftDate</a></p>
</li>
<li><p>一个简单的 UITableView/UICollectionView 的 superclass category，用于无数据时自动显示空视图<br><a href="https://github.com/dzenbot/DZNEmptyDataSet" target="_blank" rel="noopener">https://github.com/dzenbot/DZNEmptyDataSet</a></p>
</li>
<li><p>开屏广告、启动广告解决方案-支持静态/动态图片广告, mp4 视频广告,全屏/半屏广告<br><a href="https://github.com/CoderZhuXH/XHLaunchAd" target="_blank" rel="noopener">https://github.com/CoderZhuXH/XHLaunchAd</a></p>
</li>
<li><p>方便易用的相册多选框架<br><a href="https://github.com/longitachi/ZLPhotoBrowser" target="_blank" rel="noopener">https://github.com/longitachi/ZLPhotoBrowser</a></p>
</li>
<li><p>第三方 Alert 弹出框组件（SCLAlertView）<br><a href="https://github.com/vikmeup/SCLAlertView-Swift" target="_blank" rel="noopener">https://github.com/vikmeup/SCLAlertView-Swift</a></p>
</li>
<li><p>一组简单易用,极其精美的图表绘制控件<br><a href="https://github.com/AAChartModel/AAChartKit-Swift" target="_blank" rel="noopener">https://github.com/AAChartModel/AAChartKit-Swift</a></p>
</li>
<li><p>纯 Swift 下载框架<br><a href="https://github.com/Danie1s/Tiercel" target="_blank" rel="noopener">https://github.com/Danie1s/Tiercel</a></p>
</li>
<li><p>搜索记录<br><a href="https://github.com/ko1o/PYSearch" target="_blank" rel="noopener">https://github.com/ko1o/PYSearch</a></p>
</li>
<li><p>生成各种样式二维码<br><a href="https://github.com/EFPrefix/EFQRCode" target="_blank" rel="noopener">https://github.com/EFPrefix/EFQRCode</a></p>
</li>
<li><p>二维码扫描<br><a href="https://github.com/MxABC/LBXScan" target="_blank" rel="noopener">https://github.com/MxABC/LBXScan</a></p>
</li>
<li><p>致力于提高项目 UI 开发效率的解决方案<br><a href="https://github.com/Tencent/QMUI_iOS" target="_blank" rel="noopener">https://github.com/Tencent/QMUI_iOS</a></p>
</li>
<li><p>日期选择器<br><a href="https://github.com/WenchaoD/FSCalendar" target="_blank" rel="noopener">https://github.com/WenchaoD/FSCalendar</a></p>
</li>
<li><p>侧滑功能<br><a href="https://github.com/ChavezChen/CWLateralSlide" target="_blank" rel="noopener">https://github.com/ChavezChen/CWLateralSlide</a></p>
</li>
<li><p>查看大图 (Swift)<br><a href="https://github.com/JiongXing/PhotoBrowser" target="_blank" rel="noopener">https://github.com/JiongXing/PhotoBrowser</a></p>
</li>
<li><p>动画库 (Swift)<br><a href="https://github.com/airbnb/lottie-ios" target="_blank" rel="noopener">https://github.com/airbnb/lottie-ios</a></p>
</li>
</ul>
<p><strong>更多</strong>：<a href="https://github.com/iOShuyang/Book-Recommend-Github#h" target="_blank" rel="noopener">https://github.com/iOShuyang/Book-Recommend-Github#h</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>开源工具</tag>
        <tag>Swift</tag>
        <tag>Objective-C</tag>
      </tags>
  </entry>
</search>
