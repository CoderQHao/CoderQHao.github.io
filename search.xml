<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>深度工作：效率越高的人，越懂得这四种技巧</title>
    <url>/2019/05/26/%E6%B7%B1%E5%BA%A6%E5%B7%A5%E4%BD%9C%EF%BC%9A%E6%95%88%E7%8E%87%E8%B6%8A%E9%AB%98%E7%9A%84%E4%BA%BA%EF%BC%8C%E8%B6%8A%E6%87%82%E5%BE%97%E8%BF%99%E4%BA%94%E7%A7%8D%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<p><img src="/images/%E6%B7%B1%E5%BA%A6%E5%B7%A5%E4%BD%9C%EF%BC%9A%E6%95%88%E7%8E%87%E8%B6%8A%E9%AB%98%E7%9A%84%E4%BA%BA%EF%BC%8C%E8%B6%8A%E6%87%82%E5%BE%97%E8%BF%99%E4%BA%94%E7%A7%8D%E6%8A%80%E5%B7%A7/%E6%B7%B1%E5%BA%A6%E5%B7%A5%E4%BD%9C.jpg" alt="深度工作"></p>
<a id="more"></a>

<h4 id="一、工作要深入：6个策略"><a href="#一、工作要深入：6个策略" class="headerlink" title="一、工作要深入：6个策略"></a>一、工作要深入：6个策略</h4><ul>
<li><p>选定适合你的深度哲学</p>
<ul>
<li><p>禁欲主义哲学，指摒弃或最小化浮浅职责，实现深度工作最大化。如计算机科学家唐纳德·克努特通过屏蔽个人邮箱，实现无人干扰的高度专注。</p>
</li>
<li><p>双峰哲学，指将时间分成两块，分别用于深度工作和其他事务。如卡尔·荣格隐居树林里的小石屋，将一部分时间用于不受干扰地写作；其它时间则用于在诊所看病、在大学讲课等。</p>
</li>
<li><p>节奏哲学，指将深度工作转化成常规习惯。例如链条法：每天坚持某个习惯，并且在每天完成后，在日历上划一个大大的红×，过几天就能连成一条链子。继续保持下去，这条链子会越来越长。</p>
</li>
<li><p>新闻记者哲学，指随时可插入深度工作。如记者沃尔特·艾萨克森因为工作的训练，让他养成了特别的工作习惯——只要有空闲时间，他就能立刻转入深度工作模式。</p>
</li>
</ul>
</li>
<li><p>习惯化</p>
<ul>
<li><p>通过养成严格内化的习惯，实现最大化的深度工作效果。如查尔斯·达尔文在雕琢《物种起源》期间，每天按照严格的时间，有条不紊地进行拆阅信件、思考、工作等</p>
</li>
<li><p>养成高效习惯应注意的普遍问题：</p>
<ul>
<li><p>第一，确定适合进行深度工作的场所，并设定工作时长。</p>
</li>
<li><p>第二，设置工作时的规则和程序，确保努力具有结构性。比如规定不能使用网络，或者设定每隔20分钟产出的文字数量。</p>
</li>
<li><p>第三，做些事支持自己的工作，确保大脑保持高深度水平。比如提供足够的食物，或通过散步等方式帮助大脑保持清醒。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>要有大手笔</p>
<ul>
<li><p>通过对周围惯常环境做出巨大的改变，辅以投入可观的精力或金钱，由此提升任务的外现重要性。这种重要性的提升，将降低大脑继续拖延的本能，让人更有激情和能量投入深度工作。</p>
<p><code>案 例：J.K.罗琳写作《死亡圣器》期间，入住爱丁堡中心的五星级酒店，由此完成了《哈利·波特》系列的最后一本书</code></p>
</li>
</ul>
</li>
<li><p>不要独自工作</p>
<ul>
<li><p>在恰当时机采用协作方式，可以推动深度工作取得更好的成果。但不能过分追求交流，以免破坏专注的状态。</p>
<p><code>案 例：贝尔实验室的开放空间将固态物理学家、量子论学家和世界一流的实验物理学者汇聚一堂。这样的协同交流成为发明晶体管的前提。</code></p>
</li>
</ul>
</li>
<li><p>像经商一样执行（4个原则）</p>
<ul>
<li><p>第一，明确最高目标。这样有助于集中精力达成目标。</p>
</li>
<li><p>第二，抓住引领性指标，即专注于在最高目标上投入的深度工作时间。</p>
</li>
<li><p>第三，准备醒目计分板。将深度工作时间记录在计分板上，一方面营造竞争氛围，驱使人专注，另一方面可以强化动机。</p>
</li>
<li><p>第四，定期问责。比如在每周工作回顾中，反省自己的表现以不断调整，并利用它制定下一周的工作计划。</p>
</li>
</ul>
</li>
<li><p>图安逸：定期放松大脑有助于深度工作</p>
<ul>
<li><p>定期放松大脑的三个原因：</p>
<ul>
<li><p>第一，安逸时光利于提升洞察力。给有意识的头脑休息的时间，可以激活无意识头脑，从而理清复杂的工作挑战。</p>
</li>
<li><p>第二，安逸时光利于补充深度工作能量。保持专注需要自主性注意力，但它是有限的，而无干扰的休息可让自主性注意力复原。</p>
</li>
<li><p>第三，晚间安逸时光中放下的工作一般没那么重要。如果日程安排合理，白天的工作时间就已经达到每日深度工作的极限了，那么在夜里就没有足够的精力做到深度工作。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="二、拥抱无聊，克服分心：4个策略"><a href="#二、拥抱无聊，克服分心：4个策略" class="headerlink" title="二、拥抱无聊，克服分心：4个策略"></a>二、拥抱无聊，克服分心：4个策略</h4><ul>
<li><p>忌不断分心，要不断专注</p>
<ul>
<li><p>预先计划好使用网络的时间，并严格执行，通过减少自己向分心屈服的次数，提升专注力。这一策略强调三个重点：</p>
<ul>
<li><p>一是即使工作需要大量使用网络和快速回复电子邮件，这个策略也适用。</p>
</li>
<li><p>二是不论怎么计划使用网络的时段，都必须保证在这些时段外彻底屏蔽网络。</p>
</li>
<li><p>三是在工作外也按计划使用网络，可以进一步提升专注训练的效果。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>像罗斯福一样工作</p>
<ul>
<li><p>西奥多·罗斯福就读哈佛期间，兴趣广泛，同时研究自然学，而且学习成绩也十分优秀，大一时就出版了第一本书，被称为“美国最博学的青年自然学者之一”。这些成果的取得，得益于他处理学业的独特方式：从上午8点半到下午4点半这段时间，他预留出时间背诵、上课、锻炼和吃午饭，余下的时间则全部用于专注其它学习。</p>
</li>
<li><p>这一策略启发我们：<strong>在日常工作中，要不时地像罗斯福一样发起冲锋，以高强度工作，高效利用时间，实现专注力的高度集中</strong>。</p>
</li>
</ul>
</li>
<li><p>有成果的冥想</p>
<ul>
<li><p>利用本可能被浪费的时间，如在走路、慢跑、开车时，将注意力集中在某个难题上，实现有成果的冥想。有效执行这一策略，有两个建议：</p>
</li>
<li><p>一是小心分心和原地打转。它们会阻碍冥想成果，所以必须警惕和提醒自己。</p>
</li>
<li><p>二是组织你的深度思考。深度思考需要一定的架构。作者建议首先仔细考察解决这个问题的相关变量。比如你在试图解决一个数学证明，它的相关变量可能是假设或前提。通过考虑相关变量，明确下一步问题，为自己的注意力指明方向。</p>
</li>
</ul>
</li>
<li><p>记住一副牌</p>
<ul>
<li><p>人的大脑不适合记忆抽象信息，而擅长记住场景。美国记忆力冠军罗恩·怀特的记牌窍门，就是基于这一见解而获得。这一窍门包括三个步骤：</p>
<ul>
<li><p>步骤一：穿行家里的5个房间，记住每个房间看到的10件物品，再加上院子里的2件，凑齐52个。</p>
</li>
<li><p>步骤二：将52张牌中的每一张与一个难忘的人或东西相对应。为方便起先，给每一张安排一个有逻辑联想的形象。</p>
</li>
<li><p>步骤三：在脑海中穿行每个房间，把遇到的每一件物品与难忘的人或东西，以及某张牌对应起来。连续多走几次，以便铭记脑中。</p>
</li>
<li><p>作者强调这一策略的关键是：<strong>只要你愿意付出努力，就可以提高专注力</strong>。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="三、-远离社交媒体，谨慎选择网络工具：3个策略"><a href="#三、-远离社交媒体，谨慎选择网络工具：3个策略" class="headerlink" title="三、 远离社交媒体，谨慎选择网络工具：3个策略"></a>三、 远离社交媒体，谨慎选择网络工具：3个策略</h4><ul>
<li><p>采用关键少数法则</p>
<ul>
<li><p>关键少数法则，是指在许多情境中，80%的已知效果源自20%的可能原因。这提醒我们最重要的20%的活动做出了大部分的贡献。也就是说，将时间花在高影响力的活动上，才能最大限度达成目标。这一策略包括两步：</p>
<ul>
<li><p>第一步：明确职业和私人生活中的高层次目标。</p>
</li>
<li><p>第二步：以高层次目标为准绳，思考当前使用的网络工具，评估它对达成该目标是积极影响、消极影响，还是无影响。</p>
</li>
<li><p>而决断标准是：<strong>只有你认为一种工具会带来积极影响，并且这些积极影响大于消积影响时，才继续使用这种工具</strong>。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>戒掉社交媒体</p>
<ul>
<li><p>尝试30天不使用社交媒体服务，不用主动告诉他人这个消息，也不用删除这些服务。经过30天的网络孤立，针对当前戒掉的每一个服务，问自己两个问题：第一，如果一直用这种服务，过去30天会过得更好吗？第二，人们是否关心我有没有在用这种服务？</p>
</li>
<li><p>如果这两个问题的答案是“否”，那么永久戒掉这项服务，如果答案是“是”，则重新启用。如果答案不肯定或模糊，则自行决定是否重新使用。</p>
</li>
<li><p>需要强调的是：<strong>多数人在社交媒体中刷存在感的做法，让他们草率地将时间和精力碎片化。社交媒体只是产品，它们可能会有趣，但对我们的人生目标无足轻重，而且它们是我们完成深度工作的巨大阻碍</strong>。</p>
</li>
</ul>
</li>
<li><p>不要用网络来消遣</p>
<ul>
<li><p>在生活中，如果我们把每个无聊的时刻（如排队5分钟，餐厅等朋友）都用来浏览智能手机，那么大脑可能已经被重新编排，这将导致我们不能胜任深度工作。</p>
</li>
<li><p>在空闲时，如果没有给自己安排特定的任务，网络是一种极具诱惑的选择。如果你想抵御诱惑，就得给大脑找些高质量的活动代替，如读书、运动、与益友面对面交流等等。这样能避免分心，保持专注的能力，也让我们活得更充实。</p>
</li>
</ul>
</li>
</ul>
<h4 id="四、砍掉浮浅工作：5个策略"><a href="#四、砍掉浮浅工作：5个策略" class="headerlink" title="四、砍掉浮浅工作：5个策略"></a>四、砍掉浮浅工作：5个策略</h4><ul>
<li><p>做好一天的计划</p>
<ul>
<li><p>这一策略重在使人们认识到，深度工作要求我们尊重自己的时间。作者建议：为本策略准备一本笔记本，提前规划好每个工作日的工作安排。但需要注意：允许日程中有突发改变，甚至可以主动寻求改变。</p>
</li>
<li><p>具有综合计划能力和愿意修改自己计划的人，相比没有任何规划的人，将享有更多的创造性洞见。</p>
</li>
</ul>
</li>
<li><p>定量分析每项活动的深度</p>
<ul>
<li><p>这一策略，要求我们明确每个工作任务的深浅度，以便将更多的精力倾注于深度工作。</p>
</li>
<li><p>评估工作深浅度时需要注意两点：一是，需要大量专业技能的工作，极有可能是深度工作。它既有更多的价值回报，又可以锻炼能力。二是，比如让大学生能够很快上手、不会提高专业技能的工作，大多是浮浅工作。</p>
</li>
</ul>
</li>
<li><p>向老板申请浮浅工作预算</p>
<ul>
<li><p>设置浮浅工作时间，并将它控制在这个预算范围内。对于大多数非入门级知识工作岗位，浮浅工作预算通常在工作时间的30%～50%之间。</p>
</li>
<li><p>如果自己是老板，应该问自己这个问题。因为你“繁忙”的日程中，只有少部分时间真正产出价值。</p>
</li>
<li><p>如果自己是员工，应该和老板谈论这个问题。这样做是为了，使你在特定情况下，能够更合理地拒绝某项任务或减少浮浅工作量。</p>
</li>
</ul>
</li>
<li><p>5点半之前结束工作</p>
<ul>
<li><p>除极个别例外，作者不在5点半后发电子邮件。一般来说，电子邮件和我们的工作紧密相连，也就是说作者不在5点半后工作。他把这种坚持叫做固定日程生产力，即确定一个工作目标，并设置工作时间上限，达到时间上限时则停止工作，而在工作时则专注于有生产效率的深度工作。固定日程生产力能获得成果的原因有两个：</p>
<ul>
<li><p>一是，采用固定日程生产力的方法，让人在做选择时有所侧重。这样能促使我们严格缩减浮浅工作，保持深度，在解放了时间的同时，保证创造的价值也不会减少。</p>
</li>
<li><p>二是，因为时间有限，才能更谨慎地思考个人的组织习惯。这使得我们产出的价值，高于花费长时间但日程安排混乱的人。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>变得不容易联系到</p>
<ul>
<li><p>掌握电子通讯中耗费的时间和精力的控制权，有三个技巧：</p>
<ul>
<li><p>第一，让发电子邮件的人做更多工作。如作者使用“发件人过滤器”的方法：如果有人要联系他，可以在网站上找到一个特殊情况专用电子邮件地址，同时会附带“不要对收到回复报太大期望”的信息。</p>
</li>
<li><p>第二，自己在收发电子邮件时做更多工作。如作者运用“流程导向”的方法，即梳理收到邮件的信息指向哪一个项目，成功完成项目接下来要做什么？<br>在回复邮件前，多花些时间理清当前处于哪个步骤，然后强调接下来的步骤。这样可以减少收到的邮件数量和漫无目的的思维混乱。</p>
</li>
<li><p>第三，不要回复。在你职业环境允许的情况下，这一技巧可参考以下三条规则，区分哪些信息不需要回复：</p>
<ul>
<li><p>其一，邮件内容含混或者存在其他问题，很难给一个合理的回复。</p>
</li>
<li><p>其二，你对这个问题或者提议不感兴趣。</p>
</li>
<li><p>其三，如果回复，不会有好结果；如果不回复，也不会有好结果。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="五、结语"><a href="#五、结语" class="headerlink" title="五、结语"></a>五、结语</h4><blockquote>
<p>作家威妮弗雷德·加拉格尔说：<br>我将活出专注的人生，因为这是最好的选择。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">深度的生活并非你必须要这么做，而是如果你想拥有更富效率和更有意义的人生，你就得跨过舒适区和恐惧，将自己的头脑发挥到极致。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>深度工作</tag>
      </tags>
  </entry>
  <entry>
    <title>动态调试的那些事儿</title>
    <url>/2019/04/11/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
    <content><![CDATA[<blockquote>
<p>对于苹果开发者而言，<code>LLDB</code> 是无人不知的调试工具，然而此知非彼知，相信有相当规模的开发者对 <code>LLDB</code> 的了解仍然停留于几个基础命令的使用，今天让我们来重新认识一下既熟悉又陌生的 <code>LLDB</code>，看看它那些你不曾用过的强大功能，以及如何提高我们的开发效率。</p>
</blockquote>
<a id="more"></a>

<h3 id="一、什么叫动态调试"><a href="#一、什么叫动态调试" class="headerlink" title="一、什么叫动态调试"></a>一、什么叫动态调试</h3><blockquote>
<p>将程序运行起来，通过下断点、打印等⽅方式，查看参数、返回值、函数调⽤用流程等</p>
</blockquote>
<h3 id="二、Xcode-的动态调试原理"><a href="#二、Xcode-的动态调试原理" class="headerlink" title="二、Xcode 的动态调试原理"></a>二、Xcode 的动态调试原理</h3><p><img src="/images/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E5%8E%9F%E7%90%86.png" alt="动态调试原理"></p>
<ul>
<li><p>关于 <strong>GCC、LLVM、GDB、LLDB</strong></p>
<ul>
<li>Xcode 的 <code>编译器</code> 发展历程：<a href="https://www.gnu.org/software/gcc/" target="_blank" rel="noopener">GCC</a> → <a href="https://llvm.org/" target="_blank" rel="noopener">LLVM</a></li>
<li>Xcode 的 <code>调试器</code> 发展历程：<a href="https://www.gnu.org/software/gdb/" target="_blank" rel="noopener">GDB</a> → <a href="https://lldb.llvm.org/" target="_blank" rel="noopener">LLDB</a> </li>
</ul>
</li>
<li><p>debugserver一开始存放在Mac的Xcode⾥面</p>
  <figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/DeviceSupport/<span class="number">9.1</span>/DeveloperDiskImage.dmg/usr/bin/debugserver</span><br></pre></td></tr></table></figure>
</li>
<li><p>当Xcode识别到手机设备时，Xcode会自动将debugserver安装到iPhone上 </p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;Developer&#x2F;usr&#x2F;bin&#x2F;debugserver</span><br></pre></td></tr></table></figure>
</li>
<li><p>Xcode调试的局限性   </p>
<ul>
<li>一般情况下,只能调试通过 Xcode 安装的 App</li>
</ul>
</li>
</ul>
<h3 id="三、动态调试任意-App"><a href="#三、动态调试任意-App" class="headerlink" title="三、动态调试任意 App"></a>三、动态调试任意 App</h3><p><img src="/images/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E4%BB%BB%E6%84%8FApp.png" alt="动态调试任意App"></p>
<p><strong>1、debugserver 的权限问题</strong></p>
<ul>
<li>默认情况下，<code>/Developer/usr/bin/debugserver</code> 缺少一定的权限，只能调试通过 Xcode 安装的 APP，无法调试其他 App (⽐如来⾃自 App Store 的 App) </li>
<li>如果希望调试其他App，需要对 <code>debugserver</code> 重新签名，签上<strong>2</strong>个调试相关的权限<ul>
<li>get-task-allow</li>
<li>task_for_pid-allow</li>
</ul>
</li>
</ul>
<p><strong>2、如何给 debugserver 签上权限</strong></p>
<ul>
<li>iPhone上的 <code>/Developer</code> ⽬录是只读的，无法直接对 <code>/Developer/usr/bin/debugserver</code> ⽂件签名，需要先把 <code>debugserver</code> 复制到 Mac 上</li>
<li>通过 <code>ldid</code> 命令导出⽂件以前的签名权限<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ldid -e debugserver &gt; debugserver.entitlements</span><br></pre></td></tr></table></figure></li>
<li>给 <strong>debugserver.plist</strong> 文件加上 <code>get-task-allow</code> 和 <code>task_for_pid-allow</code> 权限<br><img src="/images/%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/debugserver%E6%9D%83%E9%99%90.png" alt="debugserver权限"></li>
<li>通过<code>ldid</code>命令重新签名<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ldid -S debugserver.entitlements debugserver</span><br></pre></td></tr></table></figure></li>
<li>将已经签好权限的<code>debugserver</code>放到<code>/usr/bin</code>目录，便于找到<code>debugserver</code>指令 </li>
<li><code>debugserver</code>添加执行权限<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xhmod +x &#x2F;usr&#x2F;bin&#x2F;debugserver</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>3、让 debugserver 附加到某个 App 进程</strong></p>
<ul>
<li><p>执行下面的命令:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">debugserver *:端口号 -a 进程</span><br></pre></td></tr></table></figure>

<p>*:端口号：使用 iPhone 的某个端口启动 debugserver 服务(只要不是保留端⼝号就行)</p>
<p>-a 进程：输入 App 的进程信息(进程 ID 或者进程名称)</p>
</li>
</ul>
<p><strong>4、在 Mac 上启动 LLDB，远程连接 iPhone 上的 debugserver 服务</strong></p>
<ul>
<li><p>启动LLDB</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lldb</span><br><span class="line">(lldb)</span><br></pre></td></tr></table></figure>
</li>
<li><p>连接 debugserver 服务 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) process connect connect:&#x2F;&#x2F;手机IP地址:debugserver服务端⼝号</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用 LLDB 的 <code>c</code> 命令让程序先继续运⾏</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) c</span><br></pre></td></tr></table></figure>
</li>
<li><p>接下来就可以使⽤用 LLDB 命令调试App</p>
</li>
</ul>
<p><strong>5、通过debugserver启动App</strong></p>
<ul>
<li><p>执行下面的命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">debugserver -x auto *:端⼝号 APP的可执⾏文件路径</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="四、常用LLDB指令"><a href="#四、常用LLDB指令" class="headerlink" title="四、常用LLDB指令"></a>四、常用LLDB指令</h3><ul>
<li><p>指令的格式是</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;command&gt; [&lt;subcommand&gt; [&lt;subcommand&gt;...]] &lt;action&gt; [-options [option-value]] [argument [argument...]]</span><br></pre></td></tr></table></figure>

<p>  <code>&lt;command&gt;</code>：命令</p>
<p>  <code>&lt;subcommand&gt;</code>：子命令</p>
<p>  <code>&lt;action&gt;</code>：命令操作，想在前面的命令序列的上下文中执行的一些操作</p>
<p>  <code>&lt;options&gt;</code>：命令选项，行为修改器(action modifiers)，通常带有一些值。</p>
<p>  <code>&lt;argument&gt;</code>：命令参数，据使用的命令的上下文来表示各种不同的东西</p>
<p>  <code>[]</code>：表示命令是可选的，可以有也可以没有。</p>
<p>  举个例子：给 <code>test</code> 函数设置断点</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">breakpoint set -n test</span><br></pre></td></tr></table></figure>

<p>  <strong>breakpoint</strong> 是 <code>&lt;command&gt;</code>,  <strong>set</strong> 是 <code>&lt;action&gt;</code>,  <strong>-n</strong> 是 <code>&lt;options&gt;</code> ，<strong>test</strong> 是  <code>&lt;argument&gt;</code></p>
</li>
<li><p>可以查看指令的用法：<code>help&lt;command&gt;</code>，比如</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">help breakpoint</span><br><span class="line">help breakpoint set</span><br></pre></td></tr></table></figure>
</li>
<li><p>执行⼀个表达式：<code>expression&lt;cmd-options&gt; -- &lt;expr&gt;</code></p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">expression self.view.backgroundColor &#x3D; [UIColor redColor]</span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;cmd-options&gt;</code> : 命令选项</li>
<li><code>--</code> : 命令选项结束符，表示所有的命令选项已经设置完毕，如果没有命令选项，<code>--</code> 可以省略</li>
</ul>
</li>
<li><p><code>&lt;expr&gt;</code> : 需要执⾏的表达式</p>
<ul>
<li><code>expression</code>、<code>expression --</code> 和指令  <code>print</code>、 <code>p</code>、 <code>call</code>的效果一样 </li>
<li><code>expression -O --</code> 和指令 <code>po</code> 的效果⼀样</li>
</ul>
</li>
<li><p>打印线程的堆栈信息，和指令 <code>bt</code> 的效果一样</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread backtrace</span><br></pre></td></tr></table></figure>
</li>
<li><p>让函数直接返回某个值，不会执行断点后面的代码</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread return [&lt;expr&gt;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>打印当前栈帧的变量量</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">frame variable [&lt;variable name&gt;]</span><br></pre></td></tr></table></figure>
</li>
<li><p>程序继续运行</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread continue</span><br><span class="line">continue</span><br><span class="line">c</span><br></pre></td></tr></table></figure>
</li>
<li><p>单步运⾏，把子函数当做整体一步执⾏</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread step-over</span><br><span class="line">next</span><br><span class="line">n</span><br></pre></td></tr></table></figure>
</li>
<li><p>单步运行，遇到⼦函数会进入子函数</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread step-in</span><br><span class="line">step</span><br><span class="line">s</span><br></pre></td></tr></table></figure>
</li>
<li><p>直接执⾏完当前函数的所有代码，返回到上一个函数 </p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread step-out</span><br><span class="line">finish</span><br></pre></td></tr></table></figure>
</li>
<li><p>设置断点</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">breakpoint set -a 函数地址</span><br><span class="line">breakpoint set -n 函数名</span><br><span class="line">breakpoint set -n test</span><br><span class="line">breakpoint set -n touchesBegan:withEvent:</span><br><span class="line">breakpoint set -n &quot;-[ViewController-touchesBegan:withEvent:]&quot;</span><br><span class="line">breakpoint set -r 正则表达式</span><br><span class="line">breakpoint set -s 动态库 -n 函数名</span><br></pre></td></tr></table></figure>
</li>
<li><p>列出所有的断点(每个断点都有⾃己的编号)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">breakpoint list</span><br></pre></td></tr></table></figure>
</li>
<li><p>禁用、启用、删除断点</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">breakpoint disable 断点编号</span><br><span class="line">breakpoint enable 断点编号 </span><br><span class="line">breakpoint delete 断点编号</span><br></pre></td></tr></table></figure>
</li>
<li><p>给断点预先设置需要执行的命令，到触发断点时，就会按顺序执行   </p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">breakpoint command add 断点编号</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看某个断点设置的命令</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">breakpoint command list 断点编号*</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除某个断点设置的命令</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">breakpoint command delete 断点编号</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找某个类型的信息</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">image lookup -t 类型</span><br></pre></td></tr></table></figure>
</li>
<li><p>根据内存地址查找在模块中的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">image lookup -a 地址</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找某个符号或者函数的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">image lookup -n 符号或者函数名</span><br></pre></td></tr></table></figure>
</li>
<li><p>列出所加载的模块信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">image list</span><br></pre></td></tr></table></figure>
</li>
<li><p>打印出模块的偏移地址、全路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">image list -o -f</span><br></pre></td></tr></table></figure>


</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>动态调试</tag>
      </tags>
  </entry>
  <entry>
    <title>对RunLoop的一些看法</title>
    <url>/2018/04/12/%E5%AF%B9RunLoop%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9C%8B%E6%B3%95/</url>
    <content><![CDATA[<h3 id="RunLoop介绍"><a href="#RunLoop介绍" class="headerlink" title="RunLoop介绍"></a>RunLoop介绍</h3><p>运行循环，在程序运行过程中循环做一些事情，如果没有 Runloop 程序执行完毕就会立即退出，如果有Runloop程序会一直运行，并且时时刻刻在等待用户的输入操作。RunLoop 可以在需要的时候自己跑起来运行，在没有操作的时候就停下来休息。充分节省CPU资源，提高程序性能。</p>
<a id="more"></a>

<h4 id="1、RunLoop的基本作用"><a href="#1、RunLoop的基本作用" class="headerlink" title="1、RunLoop的基本作用"></a>1、RunLoop的基本作用</h4><ul>
<li>保持程序的持续运行</li>
<li>处理App中的各种事件（比如触摸事件、定时器事件等）</li>
<li>节省CPU资源，提高程序性能：该做事时做事，该休息时休息</li>
</ul>
<hr>
<h4 id="2、RunLoop对象"><a href="#2、RunLoop对象" class="headerlink" title="2、RunLoop对象"></a>2、RunLoop对象</h4><ul>
<li><p>iOS中有2套API来访问和使用 RunLoop</p>
</li>
<li><p>Foundation：NSRunLoop</p>
</li>
<li><p>Core Foundation：CFRunLoopRef</p>
</li>
<li><p>NSRunLoop 和 CFRunLoopRef 都代表着 RunLoop 对象</p>
</li>
<li><p>NSRunLoop 是基于 CFRunLoopRef 的一层 OC 包装</p>
</li>
<li><p><a href="https://opensource.apple.com/tarballs/CF/" target="_blank" rel="noopener">CFRunLoopRef</a>是开源的</p>
</li>
</ul>
<hr>
<h4 id="3、RunLoop与线程"><a href="#3、RunLoop与线程" class="headerlink" title="3、RunLoop与线程"></a>3、RunLoop与线程</h4><ul>
<li>每条线程都有唯一的一个与之对应的 RunLoop 对象</li>
<li>RunLoop 保存在一个全局的 Dictionary 里，线程作为 key，RunLoop作为 value</li>
<li>线程刚创建时并没有 RunLoop 对象，RunLoop 会在第一次获取它时创建</li>
<li>RunLoop 会在线程结束时销毁</li>
<li>主线程的 RunLoop 已经自动获取（创建），子线程默认没有开启 RunLoop</li>
</ul>
<hr>
<h4 id="4、获取RunLoop对象"><a href="#4、获取RunLoop对象" class="headerlink" title="4、获取RunLoop对象"></a>4、获取RunLoop对象</h4><figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Foundation</span></span><br><span class="line"><span class="comment">// 获得当前线程的 RunLoop 对象</span></span><br><span class="line">[<span class="built_in">NSRunLoop</span> currentRunLoop]; </span><br><span class="line"><span class="comment">// 获得主线程的 RunLoop 对象</span></span><br><span class="line">[<span class="built_in">NSRunLoop</span> mainRunLoop]; </span><br><span class="line"></span><br><span class="line"><span class="comment">// Core Foundation</span></span><br><span class="line"><span class="comment">// 获得当前线程的 RunLoop 对象 </span></span><br><span class="line"><span class="built_in">CFRunLoopGetCurrent</span>(); </span><br><span class="line"><span class="comment">// 获得主线程的 RunLoop 对象</span></span><br><span class="line"><span class="built_in">CFRunLoopGetMain</span>();</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="5、RunLoop相关的类"><a href="#5、RunLoop相关的类" class="headerlink" title="5、RunLoop相关的类"></a>5、RunLoop相关的类</h4><p>Core Foundation 中关于 RunLoop 的5个类</p>
<ul>
<li>CFRunLoopRef</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __CFRunLoop * <span class="built_in">CFRunLoopRef</span></span><br><span class="line"><span class="keyword">struct</span> __CFRunLoop &#123;</span><br><span class="line">    pthread_t _pthread;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModes;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _commonModeItems;</span><br><span class="line">    <span class="built_in">CFRunLoopModeRef</span> _currentMode;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _modes;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>CFRunLoopModeRef</li>
</ul>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> __CFRunLoopMode * <span class="built_in">CFRunLoopModeRef</span></span><br><span class="line"><span class="keyword">struct</span> __CFRunLoopMode &#123;</span><br><span class="line">    <span class="built_in">CFStringRef</span> _name;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources0;</span><br><span class="line">    <span class="built_in">CFMutableSetRef</span> _sources1;</span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _observers;</span><br><span class="line">    <span class="built_in">CFMutableArrayRef</span> _timers;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>CFRunLoopSourceRef</li>
<li>CFRunLoopTimerRef</li>
<li>CFRunLoopObserverRef</li>
</ul>
<p><img src="../images/%E5%AF%B9RunLoop%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9C%8B%E6%B3%95/RunLoop.png" alt="RunLoop"></p>
<hr>
<h4 id="6、CFRunLoopModeRef"><a href="#6、CFRunLoopModeRef" class="headerlink" title="6、CFRunLoopModeRef"></a>6、CFRunLoopModeRef</h4><ul>
<li><p>CFRunLoopModeRef 代表 RunLoop 的运行模式</p>
</li>
<li><p>一个 RunLoop 包含若干个 Mode，每个Mode又包含若干个 Source0/Source1/Timer/Observer</p>
</li>
<li><p>RunLoop 启动时只能选择其中一个 Mode，作为 currentMode</p>
</li>
<li><p>如果需要切换 Mode，只能退出当前 Loop，再重新选择一个 Mode 进入</p>
</li>
<li><p>不同组的 Source0/Source1/Timer/Observer 能分隔开来，互不影响</p>
</li>
<li><p>如果 Mode 里没有任何 Source0/Source1/Timer/Observer，RunLoop 会立马退出</p>
</li>
<li><p>系统默认注册了5个 Mode</p>
</li>
<li><p>kCFRunLoopDefaultMode（NSDefaultRunLoopMode）：App 的默认 Mode，通常主线程是在这个 Mode 下运行的</p>
</li>
<li><p>UITrackingRunLoopMode：界面跟踪 Mode，用于 ScrollView 追踪触摸滑动，保证界面滑动时不受其他 Mode 影响</p>
</li>
<li><p>UIInitializationRunLoopMode: 在刚启动 App 时第进入的第一个 Mode，启动完成后就不再使用</p>
</li>
<li><p>GSEventReceiveRunLoopMode: 接受系统事件的内部 Mode，通常用不到</p>
</li>
<li><p>kCFRunLoopCommonModes: 这是一个占位的 Mode，没有实际作用</p>
</li>
</ul>
<hr>
<h4 id="7、RunLoop的运行逻辑"><a href="#7、RunLoop的运行逻辑" class="headerlink" title="7、RunLoop的运行逻辑"></a>7、RunLoop的运行逻辑</h4><ul>
<li><p>Source0</p>
<ul>
<li>触摸事件处理</li>
<li>performSelector:onThread:</li>
</ul>
</li>
<li><p>Source1</p>
<ul>
<li>基于 Port 的线程间通信</li>
<li>系统事件捕捉</li>
</ul>
</li>
<li><p>Timers</p>
<ul>
<li>NSTimer</li>
<li>performSelector:withObject:afterDelay:</li>
</ul>
</li>
<li><p>Observers</p>
<ul>
<li>用于监听 RunLoop 的状态</li>
<li>UI刷新（BeforeWaiting）</li>
<li>Autorelease pool（BeforeWaiting）</li>
</ul>
</li>
</ul>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="../images/%E5%AF%B9RunLoop%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9C%8B%E6%B3%95/RunLoop_Logic.png" alt="RunLoop_Logic"></h2><h4 id="7、RunLoop在实际开中的应用"><a href="#7、RunLoop在实际开中的应用" class="headerlink" title="7、RunLoop在实际开中的应用"></a>7、RunLoop在实际开中的应用</h4><ul>
<li>控制线程生命周期（线程保活）</li>
<li>解决NSTimer在滑动时停止工作的问题</li>
<li>监控应用卡顿</li>
<li>性能优化</li>
</ul>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>RunLoop</tag>
      </tags>
  </entry>
  <entry>
    <title>金额字符串格式化</title>
    <url>/2018/03/25/%E9%87%91%E9%A2%9D%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%A0%BC%E5%BC%8F%E5%8C%96/</url>
    <content><![CDATA[<blockquote>
<p>在一些金融类的 App 中，对于表示金额类的字符串，通常需要进行格式化后再显示出来。例如：</p>
</blockquote>
<ul>
<li><code>0</code> –&gt; <code>0.00</code></li>
<li><code>123</code> –&gt; <code>123.00</code></li>
<li><code>123.456</code> –&gt; <code>123.46</code></li>
<li><code>102000</code> –&gt; <code>102,000.00</code></li>
<li><code>10204500</code> –&gt; <code>10,204,500.00</code></li>
</ul>
<p>它的规则如下：</p>
<p><strong>个位数起每隔三位数字添加一个逗号，同时保留两位小数</strong>，也称为“千分位格式”。</p>
<p>苹果提供了 <code>NSNumberFormatter</code> 用来处理 <code>NSString</code> 和 <code>NSNumber</code> 之间的转化，可以满足基本的数字形式的格式化。我们通过设置 <code>NSNumberFormatter</code> 的 <code>numberStyle</code> 和 <code>positiveFormat</code> 属性，即可实现上述功能，非常简洁，代码如下：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSString</span> *)formatDecimalNumber:(<span class="built_in">NSString</span> *)string &#123;</span><br><span class="line">    <span class="keyword">if</span> (!string || string.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> string;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSNumber</span> *number = @([string doubleValue]);</span><br><span class="line">    <span class="built_in">NSNumberFormatter</span> *formatter = [[<span class="built_in">NSNumberFormatter</span> alloc] init];</span><br><span class="line">    formatter.numberStyle = kCFNumberFormatterDecimalStyle;</span><br><span class="line">    formatter.positiveFormat = <span class="string">@"###,##0.00"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *amountString = [formatter stringFromNumber:number];</span><br><span class="line">    <span class="keyword">return</span> amountString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于 <code>NSNumberFormatter</code> 更详细的用法，可以参考这篇文章的介绍：<a href="https://www.jianshu.com/p/95952b145a8e" target="_blank" rel="noopener">NSNumberFormatter 介绍和用法</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发你可能用的上的开源工具</title>
    <url>/2017/08/22/iOS%E5%BC%80%E5%8F%91%E4%BD%A0%E5%8F%AF%E8%83%BD%E7%94%A8%E7%9A%84%E4%B8%8A%E7%9A%84%E5%BC%80%E6%BA%90%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<ul>
<li><p>IBAnimatable 是一个帮助我们在 Interface Builder 和 Swift Playground 里面设计 UI, 交互, 导航模式, 换场和动画的开源库。</p>
<p><a href="https://github.com/IBAnimatable/IBAnimatable" target="_blank" rel="noopener">https://github.com/IBAnimatable/IBAnimatable</a></p>
<a id="more"></a>
</li>
<li><p>FSPagerView是一个优雅的屏幕幻灯片库。<br><a href="https://github.com/WenchaoD/FSPagerView" target="_blank" rel="noopener">https://github.com/WenchaoD/FSPagerView</a></p>
</li>
<li><p>非常好用的帮助处理 Date 相关的库。灵活运用了 swift 的重载操作符、扩展等特性，使得时间可以直观的进行算术运算：比较大小，直接加减等。常见的时间也字符串的转换也做了良好的支持。<br><a href="https://github.com/malcommac/SwiftDate" target="_blank" rel="noopener">https://github.com/malcommac/SwiftDate</a></p>
</li>
<li><p>一个简单的 UITableView/UICollectionView 的 superclass category，用于无数据时自动显示空视图<br><a href="https://github.com/dzenbot/DZNEmptyDataSet" target="_blank" rel="noopener">https://github.com/dzenbot/DZNEmptyDataSet</a></p>
</li>
<li><p>开屏广告、启动广告解决方案-支持静态/动态图片广告, mp4 视频广告,全屏/半屏广告<br><a href="https://github.com/CoderZhuXH/XHLaunchAd" target="_blank" rel="noopener">https://github.com/CoderZhuXH/XHLaunchAd</a></p>
</li>
<li><p>方便易用的相册多选框架<br><a href="https://github.com/longitachi/ZLPhotoBrowser" target="_blank" rel="noopener">https://github.com/longitachi/ZLPhotoBrowser</a></p>
</li>
<li><p>第三方 Alert 弹出框组件（SCLAlertView）<br><a href="https://github.com/vikmeup/SCLAlertView-Swift" target="_blank" rel="noopener">https://github.com/vikmeup/SCLAlertView-Swift</a></p>
</li>
<li><p>一组简单易用,极其精美的图表绘制控件<br><a href="https://github.com/AAChartModel/AAChartKit-Swift" target="_blank" rel="noopener">https://github.com/AAChartModel/AAChartKit-Swift</a></p>
</li>
<li><p>纯 Swift 下载框架<br><a href="https://github.com/Danie1s/Tiercel" target="_blank" rel="noopener">https://github.com/Danie1s/Tiercel</a></p>
</li>
<li><p>搜索记录<br><a href="https://github.com/ko1o/PYSearch" target="_blank" rel="noopener">https://github.com/ko1o/PYSearch</a></p>
</li>
<li><p>生成各种样式二维码<br><a href="https://github.com/EFPrefix/EFQRCode" target="_blank" rel="noopener">https://github.com/EFPrefix/EFQRCode</a></p>
</li>
<li><p>二维码扫描<br><a href="https://github.com/MxABC/LBXScan" target="_blank" rel="noopener">https://github.com/MxABC/LBXScan</a></p>
</li>
<li><p>致力于提高项目 UI 开发效率的解决方案<br><a href="https://github.com/Tencent/QMUI_iOS" target="_blank" rel="noopener">https://github.com/Tencent/QMUI_iOS</a></p>
</li>
<li><p>日期选择器<br><a href="https://github.com/WenchaoD/FSCalendar" target="_blank" rel="noopener">https://github.com/WenchaoD/FSCalendar</a></p>
</li>
<li><p>侧滑功能<br><a href="https://github.com/ChavezChen/CWLateralSlide" target="_blank" rel="noopener">https://github.com/ChavezChen/CWLateralSlide</a></p>
</li>
<li><p>查看大图 (Swift)<br><a href="https://github.com/JiongXing/PhotoBrowser" target="_blank" rel="noopener">https://github.com/JiongXing/PhotoBrowser</a></p>
</li>
<li><p>动画库 (Swift)<br><a href="https://github.com/airbnb/lottie-ios" target="_blank" rel="noopener">https://github.com/airbnb/lottie-ios</a></p>
</li>
</ul>
<p><strong>更多</strong>：<a href="https://github.com/iOShuyang/Book-Recommend-Github#h" target="_blank" rel="noopener">https://github.com/iOShuyang/Book-Recommend-Github#h</a></p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>开源工具</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
</search>
